/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// InflationSwapAllOf
    /// </summary>
    [DataContract(Name = "InflationSwap_allOf")]
    public partial class InflationSwapAllOf : IEquatable<InflationSwapAllOf>, IValidatableObject
    {
        /// <summary>
        /// The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap
        /// </summary>
        /// <value>The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum InstrumentTypeEnum
        {
            /// <summary>
            /// Enum QuotedSecurity for value: QuotedSecurity
            /// </summary>
            [EnumMember(Value = "QuotedSecurity")]
            QuotedSecurity = 1,

            /// <summary>
            /// Enum InterestRateSwap for value: InterestRateSwap
            /// </summary>
            [EnumMember(Value = "InterestRateSwap")]
            InterestRateSwap = 2,

            /// <summary>
            /// Enum FxForward for value: FxForward
            /// </summary>
            [EnumMember(Value = "FxForward")]
            FxForward = 3,

            /// <summary>
            /// Enum Future for value: Future
            /// </summary>
            [EnumMember(Value = "Future")]
            Future = 4,

            /// <summary>
            /// Enum ExoticInstrument for value: ExoticInstrument
            /// </summary>
            [EnumMember(Value = "ExoticInstrument")]
            ExoticInstrument = 5,

            /// <summary>
            /// Enum FxOption for value: FxOption
            /// </summary>
            [EnumMember(Value = "FxOption")]
            FxOption = 6,

            /// <summary>
            /// Enum CreditDefaultSwap for value: CreditDefaultSwap
            /// </summary>
            [EnumMember(Value = "CreditDefaultSwap")]
            CreditDefaultSwap = 7,

            /// <summary>
            /// Enum InterestRateSwaption for value: InterestRateSwaption
            /// </summary>
            [EnumMember(Value = "InterestRateSwaption")]
            InterestRateSwaption = 8,

            /// <summary>
            /// Enum Bond for value: Bond
            /// </summary>
            [EnumMember(Value = "Bond")]
            Bond = 9,

            /// <summary>
            /// Enum EquityOption for value: EquityOption
            /// </summary>
            [EnumMember(Value = "EquityOption")]
            EquityOption = 10,

            /// <summary>
            /// Enum FixedLeg for value: FixedLeg
            /// </summary>
            [EnumMember(Value = "FixedLeg")]
            FixedLeg = 11,

            /// <summary>
            /// Enum FloatingLeg for value: FloatingLeg
            /// </summary>
            [EnumMember(Value = "FloatingLeg")]
            FloatingLeg = 12,

            /// <summary>
            /// Enum BespokeCashFlowsLeg for value: BespokeCashFlowsLeg
            /// </summary>
            [EnumMember(Value = "BespokeCashFlowsLeg")]
            BespokeCashFlowsLeg = 13,

            /// <summary>
            /// Enum Unknown for value: Unknown
            /// </summary>
            [EnumMember(Value = "Unknown")]
            Unknown = 14,

            /// <summary>
            /// Enum TermDeposit for value: TermDeposit
            /// </summary>
            [EnumMember(Value = "TermDeposit")]
            TermDeposit = 15,

            /// <summary>
            /// Enum ContractForDifference for value: ContractForDifference
            /// </summary>
            [EnumMember(Value = "ContractForDifference")]
            ContractForDifference = 16,

            /// <summary>
            /// Enum EquitySwap for value: EquitySwap
            /// </summary>
            [EnumMember(Value = "EquitySwap")]
            EquitySwap = 17,

            /// <summary>
            /// Enum CashPerpetual for value: CashPerpetual
            /// </summary>
            [EnumMember(Value = "CashPerpetual")]
            CashPerpetual = 18,

            /// <summary>
            /// Enum CapFloor for value: CapFloor
            /// </summary>
            [EnumMember(Value = "CapFloor")]
            CapFloor = 19,

            /// <summary>
            /// Enum CashSettled for value: CashSettled
            /// </summary>
            [EnumMember(Value = "CashSettled")]
            CashSettled = 20,

            /// <summary>
            /// Enum CdsIndex for value: CdsIndex
            /// </summary>
            [EnumMember(Value = "CdsIndex")]
            CdsIndex = 21,

            /// <summary>
            /// Enum Basket for value: Basket
            /// </summary>
            [EnumMember(Value = "Basket")]
            Basket = 22,

            /// <summary>
            /// Enum FundingLeg for value: FundingLeg
            /// </summary>
            [EnumMember(Value = "FundingLeg")]
            FundingLeg = 23,

            /// <summary>
            /// Enum FxSwap for value: FxSwap
            /// </summary>
            [EnumMember(Value = "FxSwap")]
            FxSwap = 24,

            /// <summary>
            /// Enum ForwardRateAgreement for value: ForwardRateAgreement
            /// </summary>
            [EnumMember(Value = "ForwardRateAgreement")]
            ForwardRateAgreement = 25,

            /// <summary>
            /// Enum SimpleInstrument for value: SimpleInstrument
            /// </summary>
            [EnumMember(Value = "SimpleInstrument")]
            SimpleInstrument = 26,

            /// <summary>
            /// Enum Repo for value: Repo
            /// </summary>
            [EnumMember(Value = "Repo")]
            Repo = 27,

            /// <summary>
            /// Enum Equity for value: Equity
            /// </summary>
            [EnumMember(Value = "Equity")]
            Equity = 28,

            /// <summary>
            /// Enum ExchangeTradedOption for value: ExchangeTradedOption
            /// </summary>
            [EnumMember(Value = "ExchangeTradedOption")]
            ExchangeTradedOption = 29,

            /// <summary>
            /// Enum ReferenceInstrument for value: ReferenceInstrument
            /// </summary>
            [EnumMember(Value = "ReferenceInstrument")]
            ReferenceInstrument = 30,

            /// <summary>
            /// Enum ComplexBond for value: ComplexBond
            /// </summary>
            [EnumMember(Value = "ComplexBond")]
            ComplexBond = 31,

            /// <summary>
            /// Enum InflationLinkedBond for value: InflationLinkedBond
            /// </summary>
            [EnumMember(Value = "InflationLinkedBond")]
            InflationLinkedBond = 32,

            /// <summary>
            /// Enum InflationSwap for value: InflationSwap
            /// </summary>
            [EnumMember(Value = "InflationSwap")]
            InflationSwap = 33,

            /// <summary>
            /// Enum SimpleCashFlowLoan for value: SimpleCashFlowLoan
            /// </summary>
            [EnumMember(Value = "SimpleCashFlowLoan")]
            SimpleCashFlowLoan = 34,

            /// <summary>
            /// Enum TotalReturnSwap for value: TotalReturnSwap
            /// </summary>
            [EnumMember(Value = "TotalReturnSwap")]
            TotalReturnSwap = 35

        }


        /// <summary>
        /// The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap
        /// </summary>
        /// <value>The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap</value>
        [DataMember(Name = "instrumentType", IsRequired = true, EmitDefaultValue = true)]
        public InstrumentTypeEnum InstrumentType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="InflationSwapAllOf" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected InflationSwapAllOf() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InflationSwapAllOf" /> class.
        /// </summary>
        /// <param name="startDate">The start date of the instrument. This is normally synonymous with the trade-date. (required).</param>
        /// <param name="maturityDate">The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it. (required).</param>
        /// <param name="flowConventions">flowConventions (required).</param>
        /// <param name="fixedRate">Fixed Rate (required).</param>
        /// <param name="inflationCap">Optional cap, needed for LPI swaps. Should not be set for ZCIIS..</param>
        /// <param name="inflationFloor">Optional floor, needed for LPI swaps. Should not be set for ZCIIS..</param>
        /// <param name="inflationFrequency">Frequency of inflation updated. Optional and defaults to Monthly which is the most common.  However both Australian and New Zealand inflation is published Quarterly. Only tenors of 1M or 3M are supported..</param>
        /// <param name="inflationIndexName">Name of the Inflation Index (required).</param>
        /// <param name="inflationInterpolation">Inflation Interpolation flag, defaults to Linear but some older swaps require Flat.    Supported string (enumeration) values are: [Linear, Flat]..</param>
        /// <param name="inflationRollDay">Day of the month that inflation rolls from one month to the next. This is optional and defaults to 1, which is  the typically value for the majority of inflation bonds (exceptions include Japan which rolls on the 10th  and some LatAm bonds which roll on the 15th)..</param>
        /// <param name="notional">The notional (required).</param>
        /// <param name="observationLag">Observation Lag, must be a number of Months, typically 3 or 4 but sometimes 8. (required).</param>
        /// <param name="payReceive">PayReceive flag for the inflation leg.  This field is optional and defaults to Pay.  If set to Pay, this swap pays inflation and receives fixed.    Supported string (enumeration) values are: [Pay, Receive]..</param>
        /// <param name="instrumentType">The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap (required).</param>
        public InflationSwapAllOf(DateTimeOffset startDate = default(DateTimeOffset), DateTimeOffset maturityDate = default(DateTimeOffset), FlowConventions flowConventions = default(FlowConventions), decimal fixedRate = default(decimal), decimal? inflationCap = default(decimal?), decimal? inflationFloor = default(decimal?), string inflationFrequency = default(string), string inflationIndexName = default(string), string inflationInterpolation = default(string), int inflationRollDay = default(int), decimal notional = default(decimal), string observationLag = default(string), string payReceive = default(string), InstrumentTypeEnum instrumentType = default(InstrumentTypeEnum))
        {
            this.StartDate = startDate;
            this.MaturityDate = maturityDate;
            // to ensure "flowConventions" is required (not null)
            if (flowConventions == null)
            {
                throw new ArgumentNullException("flowConventions is a required property for InflationSwapAllOf and cannot be null");
            }
            this.FlowConventions = flowConventions;
            this.FixedRate = fixedRate;
            // to ensure "inflationIndexName" is required (not null)
            if (inflationIndexName == null)
            {
                throw new ArgumentNullException("inflationIndexName is a required property for InflationSwapAllOf and cannot be null");
            }
            this.InflationIndexName = inflationIndexName;
            this.Notional = notional;
            // to ensure "observationLag" is required (not null)
            if (observationLag == null)
            {
                throw new ArgumentNullException("observationLag is a required property for InflationSwapAllOf and cannot be null");
            }
            this.ObservationLag = observationLag;
            this.InstrumentType = instrumentType;
            this.InflationCap = inflationCap;
            this.InflationFloor = inflationFloor;
            this.InflationFrequency = inflationFrequency;
            this.InflationInterpolation = inflationInterpolation;
            this.InflationRollDay = inflationRollDay;
            this.PayReceive = payReceive;
        }

        /// <summary>
        /// The start date of the instrument. This is normally synonymous with the trade-date.
        /// </summary>
        /// <value>The start date of the instrument. This is normally synonymous with the trade-date.</value>
        [DataMember(Name = "startDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.
        /// </summary>
        /// <value>The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.</value>
        [DataMember(Name = "maturityDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset MaturityDate { get; set; }

        /// <summary>
        /// Gets or Sets FlowConventions
        /// </summary>
        [DataMember(Name = "flowConventions", IsRequired = true, EmitDefaultValue = true)]
        public FlowConventions FlowConventions { get; set; }

        /// <summary>
        /// Fixed Rate
        /// </summary>
        /// <value>Fixed Rate</value>
        [DataMember(Name = "fixedRate", IsRequired = true, EmitDefaultValue = true)]
        public decimal FixedRate { get; set; }

        /// <summary>
        /// Optional cap, needed for LPI swaps. Should not be set for ZCIIS.
        /// </summary>
        /// <value>Optional cap, needed for LPI swaps. Should not be set for ZCIIS.</value>
        [DataMember(Name = "inflationCap", EmitDefaultValue = true)]
        public decimal? InflationCap { get; set; }

        /// <summary>
        /// Optional floor, needed for LPI swaps. Should not be set for ZCIIS.
        /// </summary>
        /// <value>Optional floor, needed for LPI swaps. Should not be set for ZCIIS.</value>
        [DataMember(Name = "inflationFloor", EmitDefaultValue = true)]
        public decimal? InflationFloor { get; set; }

        /// <summary>
        /// Frequency of inflation updated. Optional and defaults to Monthly which is the most common.  However both Australian and New Zealand inflation is published Quarterly. Only tenors of 1M or 3M are supported.
        /// </summary>
        /// <value>Frequency of inflation updated. Optional and defaults to Monthly which is the most common.  However both Australian and New Zealand inflation is published Quarterly. Only tenors of 1M or 3M are supported.</value>
        [DataMember(Name = "inflationFrequency", EmitDefaultValue = true)]
        public string InflationFrequency { get; set; }

        /// <summary>
        /// Name of the Inflation Index
        /// </summary>
        /// <value>Name of the Inflation Index</value>
        [DataMember(Name = "inflationIndexName", IsRequired = true, EmitDefaultValue = true)]
        public string InflationIndexName { get; set; }

        /// <summary>
        /// Inflation Interpolation flag, defaults to Linear but some older swaps require Flat.    Supported string (enumeration) values are: [Linear, Flat].
        /// </summary>
        /// <value>Inflation Interpolation flag, defaults to Linear but some older swaps require Flat.    Supported string (enumeration) values are: [Linear, Flat].</value>
        [DataMember(Name = "inflationInterpolation", EmitDefaultValue = true)]
        public string InflationInterpolation { get; set; }

        /// <summary>
        /// Day of the month that inflation rolls from one month to the next. This is optional and defaults to 1, which is  the typically value for the majority of inflation bonds (exceptions include Japan which rolls on the 10th  and some LatAm bonds which roll on the 15th).
        /// </summary>
        /// <value>Day of the month that inflation rolls from one month to the next. This is optional and defaults to 1, which is  the typically value for the majority of inflation bonds (exceptions include Japan which rolls on the 10th  and some LatAm bonds which roll on the 15th).</value>
        [DataMember(Name = "inflationRollDay", EmitDefaultValue = false)]
        public int InflationRollDay { get; set; }

        /// <summary>
        /// The notional
        /// </summary>
        /// <value>The notional</value>
        [DataMember(Name = "notional", IsRequired = true, EmitDefaultValue = true)]
        public decimal Notional { get; set; }

        /// <summary>
        /// Observation Lag, must be a number of Months, typically 3 or 4 but sometimes 8.
        /// </summary>
        /// <value>Observation Lag, must be a number of Months, typically 3 or 4 but sometimes 8.</value>
        [DataMember(Name = "observationLag", IsRequired = true, EmitDefaultValue = true)]
        public string ObservationLag { get; set; }

        /// <summary>
        /// PayReceive flag for the inflation leg.  This field is optional and defaults to Pay.  If set to Pay, this swap pays inflation and receives fixed.    Supported string (enumeration) values are: [Pay, Receive].
        /// </summary>
        /// <value>PayReceive flag for the inflation leg.  This field is optional and defaults to Pay.  If set to Pay, this swap pays inflation and receives fixed.    Supported string (enumeration) values are: [Pay, Receive].</value>
        [DataMember(Name = "payReceive", EmitDefaultValue = true)]
        public string PayReceive { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class InflationSwapAllOf {\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  MaturityDate: ").Append(MaturityDate).Append("\n");
            sb.Append("  FlowConventions: ").Append(FlowConventions).Append("\n");
            sb.Append("  FixedRate: ").Append(FixedRate).Append("\n");
            sb.Append("  InflationCap: ").Append(InflationCap).Append("\n");
            sb.Append("  InflationFloor: ").Append(InflationFloor).Append("\n");
            sb.Append("  InflationFrequency: ").Append(InflationFrequency).Append("\n");
            sb.Append("  InflationIndexName: ").Append(InflationIndexName).Append("\n");
            sb.Append("  InflationInterpolation: ").Append(InflationInterpolation).Append("\n");
            sb.Append("  InflationRollDay: ").Append(InflationRollDay).Append("\n");
            sb.Append("  Notional: ").Append(Notional).Append("\n");
            sb.Append("  ObservationLag: ").Append(ObservationLag).Append("\n");
            sb.Append("  PayReceive: ").Append(PayReceive).Append("\n");
            sb.Append("  InstrumentType: ").Append(InstrumentType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as InflationSwapAllOf);
        }

        /// <summary>
        /// Returns true if InflationSwapAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of InflationSwapAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InflationSwapAllOf input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && 
                (
                    this.MaturityDate == input.MaturityDate ||
                    (this.MaturityDate != null &&
                    this.MaturityDate.Equals(input.MaturityDate))
                ) && 
                (
                    this.FlowConventions == input.FlowConventions ||
                    (this.FlowConventions != null &&
                    this.FlowConventions.Equals(input.FlowConventions))
                ) && 
                (
                    this.FixedRate == input.FixedRate ||
                    this.FixedRate.Equals(input.FixedRate)
                ) && 
                (
                    this.InflationCap == input.InflationCap ||
                    (this.InflationCap != null &&
                    this.InflationCap.Equals(input.InflationCap))
                ) && 
                (
                    this.InflationFloor == input.InflationFloor ||
                    (this.InflationFloor != null &&
                    this.InflationFloor.Equals(input.InflationFloor))
                ) && 
                (
                    this.InflationFrequency == input.InflationFrequency ||
                    (this.InflationFrequency != null &&
                    this.InflationFrequency.Equals(input.InflationFrequency))
                ) && 
                (
                    this.InflationIndexName == input.InflationIndexName ||
                    (this.InflationIndexName != null &&
                    this.InflationIndexName.Equals(input.InflationIndexName))
                ) && 
                (
                    this.InflationInterpolation == input.InflationInterpolation ||
                    (this.InflationInterpolation != null &&
                    this.InflationInterpolation.Equals(input.InflationInterpolation))
                ) && 
                (
                    this.InflationRollDay == input.InflationRollDay ||
                    this.InflationRollDay.Equals(input.InflationRollDay)
                ) && 
                (
                    this.Notional == input.Notional ||
                    this.Notional.Equals(input.Notional)
                ) && 
                (
                    this.ObservationLag == input.ObservationLag ||
                    (this.ObservationLag != null &&
                    this.ObservationLag.Equals(input.ObservationLag))
                ) && 
                (
                    this.PayReceive == input.PayReceive ||
                    (this.PayReceive != null &&
                    this.PayReceive.Equals(input.PayReceive))
                ) && 
                (
                    this.InstrumentType == input.InstrumentType ||
                    this.InstrumentType.Equals(input.InstrumentType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.StartDate != null)
                {
                    hashCode = (hashCode * 59) + this.StartDate.GetHashCode();
                }
                if (this.MaturityDate != null)
                {
                    hashCode = (hashCode * 59) + this.MaturityDate.GetHashCode();
                }
                if (this.FlowConventions != null)
                {
                    hashCode = (hashCode * 59) + this.FlowConventions.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.FixedRate.GetHashCode();
                if (this.InflationCap != null)
                {
                    hashCode = (hashCode * 59) + this.InflationCap.GetHashCode();
                }
                if (this.InflationFloor != null)
                {
                    hashCode = (hashCode * 59) + this.InflationFloor.GetHashCode();
                }
                if (this.InflationFrequency != null)
                {
                    hashCode = (hashCode * 59) + this.InflationFrequency.GetHashCode();
                }
                if (this.InflationIndexName != null)
                {
                    hashCode = (hashCode * 59) + this.InflationIndexName.GetHashCode();
                }
                if (this.InflationInterpolation != null)
                {
                    hashCode = (hashCode * 59) + this.InflationInterpolation.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.InflationRollDay.GetHashCode();
                hashCode = (hashCode * 59) + this.Notional.GetHashCode();
                if (this.ObservationLag != null)
                {
                    hashCode = (hashCode * 59) + this.ObservationLag.GetHashCode();
                }
                if (this.PayReceive != null)
                {
                    hashCode = (hashCode * 59) + this.PayReceive.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.InstrumentType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // InflationIndexName (string) minLength
            if (this.InflationIndexName != null && this.InflationIndexName.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for InflationIndexName, length must be greater than 1.", new [] { "InflationIndexName" });
            }

            // ObservationLag (string) minLength
            if (this.ObservationLag != null && this.ObservationLag.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ObservationLag, length must be greater than 1.", new [] { "ObservationLag" });
            }

            yield break;
        }
    }
}
