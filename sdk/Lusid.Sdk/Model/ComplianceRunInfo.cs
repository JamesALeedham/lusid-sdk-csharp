/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// ComplianceRunInfo
    /// </summary>
    [DataContract(Name = "ComplianceRunInfo")]
    public partial class ComplianceRunInfo : IEquatable<ComplianceRunInfo>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ComplianceRunInfo" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ComplianceRunInfo() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ComplianceRunInfo" /> class.
        /// </summary>
        /// <param name="runId">The unique identifier of a compliance run (required).</param>
        /// <param name="instigatedAt">The time the compliance run was launched (e.g. button pressed). Currently it is also both the as at and effective at time in whichthe rule set and portfolio data (including any pending trades if the run is pretrade) is taken for the caluation, although it may be possible to run compliance for historical effective at and as at dates in the future. (required).</param>
        /// <param name="completedAt">The time the compliance run calculation was completed (required).</param>
        /// <param name="schedule">Whether the compliance run was pre or post trade (required).</param>
        /// <param name="allRulesPassed">True if all rules passed, for all the portfolios they were assigned to (required).</param>
        /// <param name="hasResults">False when no results have been returned eg. when no rules exist (required).</param>
        /// <param name="asAt">Legacy AsAt time for backwards compatibility (required).</param>
        public ComplianceRunInfo(string runId = default(string), DateTimeOffset instigatedAt = default(DateTimeOffset), DateTimeOffset completedAt = default(DateTimeOffset), string schedule = default(string), bool allRulesPassed = default(bool), bool hasResults = default(bool), DateTimeOffset asAt = default(DateTimeOffset))
        {
            // to ensure "runId" is required (not null)
            if (runId == null)
            {
                throw new ArgumentNullException("runId is a required property for ComplianceRunInfo and cannot be null");
            }
            this.RunId = runId;
            this.InstigatedAt = instigatedAt;
            this.CompletedAt = completedAt;
            // to ensure "schedule" is required (not null)
            if (schedule == null)
            {
                throw new ArgumentNullException("schedule is a required property for ComplianceRunInfo and cannot be null");
            }
            this.Schedule = schedule;
            this.AllRulesPassed = allRulesPassed;
            this.HasResults = hasResults;
            this.AsAt = asAt;
        }

        /// <summary>
        /// The unique identifier of a compliance run
        /// </summary>
        /// <value>The unique identifier of a compliance run</value>
        [DataMember(Name = "runId", IsRequired = true, EmitDefaultValue = true)]
        public string RunId { get; set; }

        /// <summary>
        /// The time the compliance run was launched (e.g. button pressed). Currently it is also both the as at and effective at time in whichthe rule set and portfolio data (including any pending trades if the run is pretrade) is taken for the caluation, although it may be possible to run compliance for historical effective at and as at dates in the future.
        /// </summary>
        /// <value>The time the compliance run was launched (e.g. button pressed). Currently it is also both the as at and effective at time in whichthe rule set and portfolio data (including any pending trades if the run is pretrade) is taken for the caluation, although it may be possible to run compliance for historical effective at and as at dates in the future.</value>
        [DataMember(Name = "instigatedAt", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset InstigatedAt { get; set; }

        /// <summary>
        /// The time the compliance run calculation was completed
        /// </summary>
        /// <value>The time the compliance run calculation was completed</value>
        [DataMember(Name = "completedAt", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset CompletedAt { get; set; }

        /// <summary>
        /// Whether the compliance run was pre or post trade
        /// </summary>
        /// <value>Whether the compliance run was pre or post trade</value>
        [DataMember(Name = "schedule", IsRequired = true, EmitDefaultValue = true)]
        public string Schedule { get; set; }

        /// <summary>
        /// True if all rules passed, for all the portfolios they were assigned to
        /// </summary>
        /// <value>True if all rules passed, for all the portfolios they were assigned to</value>
        [DataMember(Name = "allRulesPassed", IsRequired = true, EmitDefaultValue = true)]
        public bool AllRulesPassed { get; set; }

        /// <summary>
        /// False when no results have been returned eg. when no rules exist
        /// </summary>
        /// <value>False when no results have been returned eg. when no rules exist</value>
        [DataMember(Name = "hasResults", IsRequired = true, EmitDefaultValue = true)]
        public bool HasResults { get; set; }

        /// <summary>
        /// Legacy AsAt time for backwards compatibility
        /// </summary>
        /// <value>Legacy AsAt time for backwards compatibility</value>
        [DataMember(Name = "asAt", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset AsAt { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ComplianceRunInfo {\n");
            sb.Append("  RunId: ").Append(RunId).Append("\n");
            sb.Append("  InstigatedAt: ").Append(InstigatedAt).Append("\n");
            sb.Append("  CompletedAt: ").Append(CompletedAt).Append("\n");
            sb.Append("  Schedule: ").Append(Schedule).Append("\n");
            sb.Append("  AllRulesPassed: ").Append(AllRulesPassed).Append("\n");
            sb.Append("  HasResults: ").Append(HasResults).Append("\n");
            sb.Append("  AsAt: ").Append(AsAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ComplianceRunInfo);
        }

        /// <summary>
        /// Returns true if ComplianceRunInfo instances are equal
        /// </summary>
        /// <param name="input">Instance of ComplianceRunInfo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ComplianceRunInfo input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.RunId == input.RunId ||
                    (this.RunId != null &&
                    this.RunId.Equals(input.RunId))
                ) && 
                (
                    this.InstigatedAt == input.InstigatedAt ||
                    (this.InstigatedAt != null &&
                    this.InstigatedAt.Equals(input.InstigatedAt))
                ) && 
                (
                    this.CompletedAt == input.CompletedAt ||
                    (this.CompletedAt != null &&
                    this.CompletedAt.Equals(input.CompletedAt))
                ) && 
                (
                    this.Schedule == input.Schedule ||
                    (this.Schedule != null &&
                    this.Schedule.Equals(input.Schedule))
                ) && 
                (
                    this.AllRulesPassed == input.AllRulesPassed ||
                    this.AllRulesPassed.Equals(input.AllRulesPassed)
                ) && 
                (
                    this.HasResults == input.HasResults ||
                    this.HasResults.Equals(input.HasResults)
                ) && 
                (
                    this.AsAt == input.AsAt ||
                    (this.AsAt != null &&
                    this.AsAt.Equals(input.AsAt))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.RunId != null)
                {
                    hashCode = (hashCode * 59) + this.RunId.GetHashCode();
                }
                if (this.InstigatedAt != null)
                {
                    hashCode = (hashCode * 59) + this.InstigatedAt.GetHashCode();
                }
                if (this.CompletedAt != null)
                {
                    hashCode = (hashCode * 59) + this.CompletedAt.GetHashCode();
                }
                if (this.Schedule != null)
                {
                    hashCode = (hashCode * 59) + this.Schedule.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AllRulesPassed.GetHashCode();
                hashCode = (hashCode * 59) + this.HasResults.GetHashCode();
                if (this.AsAt != null)
                {
                    hashCode = (hashCode * 59) + this.AsAt.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // RunId (string) minLength
            if (this.RunId != null && this.RunId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RunId, length must be greater than 1.", new [] { "RunId" });
            }

            // Schedule (string) minLength
            if (this.Schedule != null && this.Schedule.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Schedule, length must be greater than 1.", new [] { "Schedule" });
            }

            yield break;
        }
    }
}
