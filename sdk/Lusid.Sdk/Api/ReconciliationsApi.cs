/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Lusid.Sdk.Client;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReconciliationsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Create a scheduled reconciliation for the given request
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Reconciliation</returns>
        Reconciliation CreateScheduledReconciliation(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Create a scheduled reconciliation for the given request
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Reconciliation</returns>
        ApiResponse<Reconciliation> CreateScheduledReconciliationWithHttpInfo(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Delete the given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteReconciliation(string scope, string code, int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Delete the given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeleteReconciliationWithHttpInfo(string scope, string code, int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteReconciliationBreak(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeleteReconciliationBreakWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping
        /// </summary>
        /// <remarks>
        /// Deletes the mapping identified by the scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string DeleteReconciliationMapping(string scope, string code, int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping
        /// </summary>
        /// <remarks>
        /// Deletes the mapping identified by the scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> DeleteReconciliationMappingWithHttpInfo(string scope, string code, int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteReconciliationRun(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeleteReconciliationRunWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Get the requested scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Reconciliation</returns>
        Reconciliation GetReconciliation(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Get the requested scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Reconciliation</returns>
        ApiResponse<Reconciliation> GetReconciliationWithHttpInfo(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRunBreak</returns>
        ReconciliationRunBreak GetReconciliationBreak(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRunBreak</returns>
        ApiResponse<ReconciliationRunBreak> GetReconciliationBreakWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping
        /// </summary>
        /// <remarks>
        /// Gets a mapping identified by the given scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Mapping</returns>
        Mapping GetReconciliationMapping(string scope, string code, int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping
        /// </summary>
        /// <remarks>
        /// Gets a mapping identified by the given scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Mapping</returns>
        ApiResponse<Mapping> GetReconciliationMappingWithHttpInfo(string scope, string code, int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRun</returns>
        ReconciliationRun GetReconciliationRun(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRun</returns>
        ApiResponse<ReconciliationRun> GetReconciliationRunWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks
        /// </summary>
        /// <remarks>
        /// List all reconciliation breaks associated with a given run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfReconciliationRunBreak</returns>
        PagedResourceListOfReconciliationRunBreak ListReconciliationBreaks(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks
        /// </summary>
        /// <remarks>
        /// List all reconciliation breaks associated with a given run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfReconciliationRunBreak</returns>
        ApiResponse<PagedResourceListOfReconciliationRunBreak> ListReconciliationBreaksWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings
        /// </summary>
        /// <remarks>
        /// Lists all mappings this user is entitled to see
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ResourceListOfMapping</returns>
        ResourceListOfMapping ListReconciliationMappings(string? reconciliationType = default(string?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings
        /// </summary>
        /// <remarks>
        /// Lists all mappings this user is entitled to see
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ResourceListOfMapping</returns>
        ApiResponse<ResourceListOfMapping> ListReconciliationMappingsWithHttpInfo(string? reconciliationType = default(string?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs
        /// </summary>
        /// <remarks>
        /// List all runs for a given reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfReconciliationRun</returns>
        PagedResourceListOfReconciliationRun ListReconciliationRuns(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs
        /// </summary>
        /// <remarks>
        /// List all runs for a given reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfReconciliationRun</returns>
        ApiResponse<PagedResourceListOfReconciliationRun> ListReconciliationRunsWithHttpInfo(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations
        /// </summary>
        /// <remarks>
        /// List all the scheduled reconciliations matching particular criteria
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfReconciliation</returns>
        PagedResourceListOfReconciliation ListReconciliations(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations
        /// </summary>
        /// <remarks>
        /// List all the scheduled reconciliations matching particular criteria
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfReconciliation</returns>
        ApiResponse<PagedResourceListOfReconciliation> ListReconciliationsWithHttpInfo(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0);
        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero.
        /// </summary>
        /// <remarks>
        /// Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationResponse</returns>
        ReconciliationResponse ReconcileGeneric(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero.
        /// </summary>
        /// <remarks>
        /// Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationResponse</returns>
        ApiResponse<ReconciliationResponse> ReconcileGenericWithHttpInfo(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings
        /// </summary>
        /// <remarks>
        /// Reconcile the holdings of two portfolios.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ResourceListOfReconciliationBreak</returns>
        ResourceListOfReconciliationBreak ReconcileHoldings(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings
        /// </summary>
        /// <remarks>
        /// Reconcile the holdings of two portfolios.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ResourceListOfReconciliationBreak</returns>
        ApiResponse<ResourceListOfReconciliationBreak> ReconcileHoldingsWithHttpInfo(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ListAggregationReconciliation</returns>
        ListAggregationReconciliation ReconcileInline(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ListAggregationReconciliation</returns>
        ApiResponse<ListAggregationReconciliation> ReconcileInlineWithHttpInfo(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation.
        /// </summary>
        /// <remarks>
        /// Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TransactionsReconciliationsResponse</returns>
        TransactionsReconciliationsResponse ReconcileTransactions(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation.
        /// </summary>
        /// <remarks>
        /// Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TransactionsReconciliationsResponse</returns>
        ApiResponse<TransactionsReconciliationsResponse> ReconcileTransactionsWithHttpInfo(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ListAggregationReconciliation</returns>
        ListAggregationReconciliation ReconcileValuation(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ListAggregationReconciliation</returns>
        ApiResponse<ListAggregationReconciliation> ReconcileValuationWithHttpInfo(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Update a given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Reconciliation</returns>
        Reconciliation UpdateReconciliation(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Update a given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Reconciliation</returns>
        ApiResponse<Reconciliation> UpdateReconciliationWithHttpInfo(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break
        /// </summary>
        /// <remarks>
        /// Update or create a given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRunBreak</returns>
        ReconciliationRunBreak UpsertReconciliationBreak(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break
        /// </summary>
        /// <remarks>
        /// Update or create a given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRunBreak</returns>
        ApiResponse<ReconciliationRunBreak> UpsertReconciliationBreakWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping
        /// </summary>
        /// <remarks>
        /// If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Mapping</returns>
        Mapping UpsertReconciliationMapping(Mapping? mapping = default(Mapping?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping
        /// </summary>
        /// <remarks>
        /// If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Mapping</returns>
        ApiResponse<Mapping> UpsertReconciliationMappingWithHttpInfo(Mapping? mapping = default(Mapping?), int operationIndex = 0);
        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run
        /// </summary>
        /// <remarks>
        /// Existing reconciliations will be updated, non-existing ones will be created
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRun</returns>
        ReconciliationRun UpsertReconciliationRun(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0);

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run
        /// </summary>
        /// <remarks>
        /// Existing reconciliations will be updated, non-existing ones will be created
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRun</returns>
        ApiResponse<ReconciliationRun> UpsertReconciliationRunWithHttpInfo(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReconciliationsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Create a scheduled reconciliation for the given request
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Reconciliation</returns>
        System.Threading.Tasks.Task<Reconciliation> CreateScheduledReconciliationAsync(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Create a scheduled reconciliation for the given request
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Reconciliation)</returns>
        System.Threading.Tasks.Task<ApiResponse<Reconciliation>> CreateScheduledReconciliationWithHttpInfoAsync(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Delete the given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteReconciliationAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Delete the given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeleteReconciliationWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteReconciliationBreakAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeleteReconciliationBreakWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping
        /// </summary>
        /// <remarks>
        /// Deletes the mapping identified by the scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> DeleteReconciliationMappingAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping
        /// </summary>
        /// <remarks>
        /// Deletes the mapping identified by the scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> DeleteReconciliationMappingWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteReconciliationRunAsync(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run
        /// </summary>
        /// <remarks>
        /// Delete the given reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeleteReconciliationRunWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Get the requested scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Reconciliation</returns>
        System.Threading.Tasks.Task<Reconciliation> GetReconciliationAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Get the requested scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Reconciliation)</returns>
        System.Threading.Tasks.Task<ApiResponse<Reconciliation>> GetReconciliationWithHttpInfoAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRunBreak</returns>
        System.Threading.Tasks.Task<ReconciliationRunBreak> GetReconciliationBreakAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRunBreak)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReconciliationRunBreak>> GetReconciliationBreakWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping
        /// </summary>
        /// <remarks>
        /// Gets a mapping identified by the given scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mapping</returns>
        System.Threading.Tasks.Task<Mapping> GetReconciliationMappingAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping
        /// </summary>
        /// <remarks>
        /// Gets a mapping identified by the given scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mapping)</returns>
        System.Threading.Tasks.Task<ApiResponse<Mapping>> GetReconciliationMappingWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRun</returns>
        System.Threading.Tasks.Task<ReconciliationRun> GetReconciliationRunAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run
        /// </summary>
        /// <remarks>
        /// Get the requested reconciliation run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRun)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReconciliationRun>> GetReconciliationRunWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks
        /// </summary>
        /// <remarks>
        /// List all reconciliation breaks associated with a given run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfReconciliationRunBreak</returns>
        System.Threading.Tasks.Task<PagedResourceListOfReconciliationRunBreak> ListReconciliationBreaksAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks
        /// </summary>
        /// <remarks>
        /// List all reconciliation breaks associated with a given run
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfReconciliationRunBreak)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfReconciliationRunBreak>> ListReconciliationBreaksWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings
        /// </summary>
        /// <remarks>
        /// Lists all mappings this user is entitled to see
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ResourceListOfMapping</returns>
        System.Threading.Tasks.Task<ResourceListOfMapping> ListReconciliationMappingsAsync(string? reconciliationType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings
        /// </summary>
        /// <remarks>
        /// Lists all mappings this user is entitled to see
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfMapping)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfMapping>> ListReconciliationMappingsWithHttpInfoAsync(string? reconciliationType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs
        /// </summary>
        /// <remarks>
        /// List all runs for a given reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfReconciliationRun</returns>
        System.Threading.Tasks.Task<PagedResourceListOfReconciliationRun> ListReconciliationRunsAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs
        /// </summary>
        /// <remarks>
        /// List all runs for a given reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfReconciliationRun)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfReconciliationRun>> ListReconciliationRunsWithHttpInfoAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations
        /// </summary>
        /// <remarks>
        /// List all the scheduled reconciliations matching particular criteria
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfReconciliation</returns>
        System.Threading.Tasks.Task<PagedResourceListOfReconciliation> ListReconciliationsAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations
        /// </summary>
        /// <remarks>
        /// List all the scheduled reconciliations matching particular criteria
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfReconciliation)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfReconciliation>> ListReconciliationsWithHttpInfoAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero.
        /// </summary>
        /// <remarks>
        /// Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationResponse</returns>
        System.Threading.Tasks.Task<ReconciliationResponse> ReconcileGenericAsync(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero.
        /// </summary>
        /// <remarks>
        /// Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReconciliationResponse>> ReconcileGenericWithHttpInfoAsync(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings
        /// </summary>
        /// <remarks>
        /// Reconcile the holdings of two portfolios.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ResourceListOfReconciliationBreak</returns>
        System.Threading.Tasks.Task<ResourceListOfReconciliationBreak> ReconcileHoldingsAsync(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings
        /// </summary>
        /// <remarks>
        /// Reconcile the holdings of two portfolios.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfReconciliationBreak)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfReconciliationBreak>> ReconcileHoldingsWithHttpInfoAsync(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListAggregationReconciliation</returns>
        System.Threading.Tasks.Task<ListAggregationReconciliation> ReconcileInlineAsync(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListAggregationReconciliation)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListAggregationReconciliation>> ReconcileInlineWithHttpInfoAsync(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation.
        /// </summary>
        /// <remarks>
        /// Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionsReconciliationsResponse</returns>
        System.Threading.Tasks.Task<TransactionsReconciliationsResponse> ReconcileTransactionsAsync(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation.
        /// </summary>
        /// <remarks>
        /// Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionsReconciliationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionsReconciliationsResponse>> ReconcileTransactionsWithHttpInfoAsync(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListAggregationReconciliation</returns>
        System.Threading.Tasks.Task<ListAggregationReconciliation> ReconcileValuationAsync(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListAggregationReconciliation)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListAggregationReconciliation>> ReconcileValuationWithHttpInfoAsync(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Update a given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Reconciliation</returns>
        System.Threading.Tasks.Task<Reconciliation> UpdateReconciliationAsync(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation
        /// </summary>
        /// <remarks>
        /// Update a given scheduled reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Reconciliation)</returns>
        System.Threading.Tasks.Task<ApiResponse<Reconciliation>> UpdateReconciliationWithHttpInfoAsync(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break
        /// </summary>
        /// <remarks>
        /// Update or create a given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRunBreak</returns>
        System.Threading.Tasks.Task<ReconciliationRunBreak> UpsertReconciliationBreakAsync(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break
        /// </summary>
        /// <remarks>
        /// Update or create a given reconciliation break
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRunBreak)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReconciliationRunBreak>> UpsertReconciliationBreakWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping
        /// </summary>
        /// <remarks>
        /// If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mapping</returns>
        System.Threading.Tasks.Task<Mapping> UpsertReconciliationMappingAsync(Mapping? mapping = default(Mapping?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping
        /// </summary>
        /// <remarks>
        /// If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mapping)</returns>
        System.Threading.Tasks.Task<ApiResponse<Mapping>> UpsertReconciliationMappingWithHttpInfoAsync(Mapping? mapping = default(Mapping?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run
        /// </summary>
        /// <remarks>
        /// Existing reconciliations will be updated, non-existing ones will be created
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRun</returns>
        System.Threading.Tasks.Task<ReconciliationRun> UpsertReconciliationRunAsync(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run
        /// </summary>
        /// <remarks>
        /// Existing reconciliations will be updated, non-existing ones will be created
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRun)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReconciliationRun>> UpsertReconciliationRunWithHttpInfoAsync(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReconciliationsApi : IReconciliationsApiSync, IReconciliationsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ReconciliationsApi : IReconciliationsApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReconciliationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReconciliationsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReconciliationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReconciliationsApi(string basePath)
        {
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                Lusid.Sdk.Client.GlobalConfiguration.Instance,
                new Lusid.Sdk.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReconciliationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ReconciliationsApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReconciliationsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ReconciliationsApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation Create a scheduled reconciliation for the given request
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Reconciliation</returns>
        public Reconciliation CreateScheduledReconciliation(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Reconciliation> localVarResponse = CreateScheduledReconciliationWithHttpInfo(scope, createReconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation Create a scheduled reconciliation for the given request
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Reconciliation</returns>
        public Lusid.Sdk.Client.ApiResponse<Reconciliation> CreateScheduledReconciliationWithHttpInfo(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->CreateScheduledReconciliation");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.Data = createReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.CreateScheduledReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Reconciliation>("/api/portfolios/$scheduledReconciliations/{scope}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateScheduledReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation Create a scheduled reconciliation for the given request
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Reconciliation</returns>
        public async System.Threading.Tasks.Task<Reconciliation> CreateScheduledReconciliationAsync(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Reconciliation> localVarResponse = await CreateScheduledReconciliationWithHttpInfoAsync(scope, createReconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation Create a scheduled reconciliation for the given request
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="createReconciliationRequest">The definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Reconciliation)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Reconciliation>> CreateScheduledReconciliationWithHttpInfoAsync(string scope, CreateReconciliationRequest? createReconciliationRequest = default(CreateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->CreateScheduledReconciliation");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.Data = createReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.CreateScheduledReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Reconciliation>("/api/portfolios/$scheduledReconciliations/{scope}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateScheduledReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation Delete the given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteReconciliation(string scope, string code, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteReconciliationWithHttpInfo(scope, code);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation Delete the given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteReconciliationWithHttpInfo(string scope, string code, int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliation");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/portfolios/$scheduledReconciliations/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation Delete the given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteReconciliationAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteReconciliationWithHttpInfoAsync(scope, code, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation Delete the given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteReconciliationWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliation");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/portfolios/$scheduledReconciliations/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break Delete the given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteReconciliationBreak(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteReconciliationBreakWithHttpInfo(scope, code, runDate, version, breakId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break Delete the given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteReconciliationBreakWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliationBreak");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliationBreak");
            }

            // verify the required parameter 'breakId' is set
            if (breakId == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'breakId' when calling ReconciliationsApi->DeleteReconciliationBreak");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.PathParameters.Add("breakId", Lusid.Sdk.Client.ClientUtils.ParameterToString(breakId)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliationBreak";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}/breaks/{breakId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliationBreak", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break Delete the given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteReconciliationBreakAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteReconciliationBreakWithHttpInfoAsync(scope, code, runDate, version, breakId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationBreak: Delete reconciliation break Delete the given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteReconciliationBreakWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliationBreak");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliationBreak");
            }

            // verify the required parameter 'breakId' is set
            if (breakId == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'breakId' when calling ReconciliationsApi->DeleteReconciliationBreak");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.PathParameters.Add("breakId", Lusid.Sdk.Client.ClientUtils.ParameterToString(breakId)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliationBreak";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}/breaks/{breakId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliationBreak", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping Deletes the mapping identified by the scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string DeleteReconciliationMapping(string scope, string code, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<string> localVarResponse = DeleteReconciliationMappingWithHttpInfo(scope, code);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping Deletes the mapping identified by the scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public Lusid.Sdk.Client.ApiResponse<string> DeleteReconciliationMappingWithHttpInfo(string scope, string code, int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliationMapping");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliationMapping");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliationMapping";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<string>("/api/portfolios/mapping/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliationMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping Deletes the mapping identified by the scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> DeleteReconciliationMappingAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<string> localVarResponse = await DeleteReconciliationMappingWithHttpInfoAsync(scope, code, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping Deletes the mapping identified by the scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code fof the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<string>> DeleteReconciliationMappingWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliationMapping");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliationMapping");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliationMapping";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<string>("/api/portfolios/mapping/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliationMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run Delete the given reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteReconciliationRun(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteReconciliationRunWithHttpInfo(scope, code, runDate, version);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run Delete the given reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteReconciliationRunWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliationRun");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliationRun");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliationRun";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliationRun", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run Delete the given reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteReconciliationRunAsync(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteReconciliationRunWithHttpInfoAsync(scope, code, runDate, version, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteReconciliationRun: Delete reconciliation run Delete the given reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the reconciliation run</param>
        /// <param name="version">The version number of the reconciliation run</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteReconciliationRunWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->DeleteReconciliationRun");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->DeleteReconciliationRun");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.DeleteReconciliationRun";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReconciliationRun", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation Get the requested scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Reconciliation</returns>
        public Reconciliation GetReconciliation(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Reconciliation> localVarResponse = GetReconciliationWithHttpInfo(scope, code, effectiveAt, asAt, propertyKeys);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation Get the requested scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Reconciliation</returns>
        public Lusid.Sdk.Client.ApiResponse<Reconciliation> GetReconciliationWithHttpInfo(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliation");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Reconciliation>("/api/portfolios/$scheduledReconciliations/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation Get the requested scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Reconciliation</returns>
        public async System.Threading.Tasks.Task<Reconciliation> GetReconciliationAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Reconciliation> localVarResponse = await GetReconciliationWithHttpInfoAsync(scope, code, effectiveAt, asAt, propertyKeys, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation Get the requested scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the scheduled reconciliation</param>
        /// <param name="code">The code of the scheduled reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Reconciliation)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Reconciliation>> GetReconciliationWithHttpInfoAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliation");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Reconciliation>("/api/portfolios/$scheduledReconciliations/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break Get the requested reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRunBreak</returns>
        public ReconciliationRunBreak GetReconciliationBreak(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak> localVarResponse = GetReconciliationBreakWithHttpInfo(scope, code, runDate, version, breakId, asAt);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break Get the requested reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRunBreak</returns>
        public Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak> GetReconciliationBreakWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliationBreak");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliationBreak");
            }

            // verify the required parameter 'breakId' is set
            if (breakId == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'breakId' when calling ReconciliationsApi->GetReconciliationBreak");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.PathParameters.Add("breakId", Lusid.Sdk.Client.ClientUtils.ParameterToString(breakId)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliationBreak";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReconciliationRunBreak>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}/breaks/{breakId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliationBreak", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break Get the requested reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRunBreak</returns>
        public async System.Threading.Tasks.Task<ReconciliationRunBreak> GetReconciliationBreakAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak> localVarResponse = await GetReconciliationBreakWithHttpInfoAsync(scope, code, runDate, version, breakId, asAt, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationBreak: Get reconciliation break Get the requested reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="breakId">The unique identifier for the break</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation break. Defaults to returning the latest version of the reconciliation break if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRunBreak)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak>> GetReconciliationBreakWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, string breakId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliationBreak");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliationBreak");
            }

            // verify the required parameter 'breakId' is set
            if (breakId == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'breakId' when calling ReconciliationsApi->GetReconciliationBreak");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.PathParameters.Add("breakId", Lusid.Sdk.Client.ClientUtils.ParameterToString(breakId)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliationBreak";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReconciliationRunBreak>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}/breaks/{breakId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliationBreak", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping Gets a mapping identified by the given scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Mapping</returns>
        public Mapping GetReconciliationMapping(string scope, string code, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Mapping> localVarResponse = GetReconciliationMappingWithHttpInfo(scope, code);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping Gets a mapping identified by the given scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Mapping</returns>
        public Lusid.Sdk.Client.ApiResponse<Mapping> GetReconciliationMappingWithHttpInfo(string scope, string code, int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliationMapping");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliationMapping");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliationMapping";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Mapping>("/api/portfolios/mapping/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliationMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping Gets a mapping identified by the given scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mapping</returns>
        public async System.Threading.Tasks.Task<Mapping> GetReconciliationMappingAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Mapping> localVarResponse = await GetReconciliationMappingWithHttpInfoAsync(scope, code, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetReconciliationMapping: Get a mapping Gets a mapping identified by the given scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the mapping.</param>
        /// <param name="code">The code of the mapping.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mapping)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Mapping>> GetReconciliationMappingWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliationMapping");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliationMapping");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliationMapping";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Mapping>("/api/portfolios/mapping/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliationMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run Get the requested reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRun</returns>
        public ReconciliationRun GetReconciliationRun(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRun> localVarResponse = GetReconciliationRunWithHttpInfo(scope, code, runDate, version, effectiveAt, asAt);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run Get the requested reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRun</returns>
        public Lusid.Sdk.Client.ApiResponse<ReconciliationRun> GetReconciliationRunWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliationRun");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliationRun");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliationRun";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReconciliationRun>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliationRun", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run Get the requested reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRun</returns>
        public async System.Threading.Tasks.Task<ReconciliationRun> GetReconciliationRunAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRun> localVarResponse = await GetReconciliationRunWithHttpInfoAsync(scope, code, runDate, version, effectiveAt, asAt, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetReconciliationRun: Get a reconciliation run Get the requested reconciliation run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="runDate">The date of the run</param>
        /// <param name="version">The version number of the run</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the reconciliation run. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the reconciliation run. Defaults to returning the latest version of the reconciliation run if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRun)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ReconciliationRun>> GetReconciliationRunWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->GetReconciliationRun");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->GetReconciliationRun");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.GetReconciliationRun";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReconciliationRun>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReconciliationRun", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks List all reconciliation breaks associated with a given run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfReconciliationRunBreak</returns>
        public PagedResourceListOfReconciliationRunBreak ListReconciliationBreaks(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRunBreak> localVarResponse = ListReconciliationBreaksWithHttpInfo(scope, code, runDate, version, effectiveAt, asAt, page, start, limit, filter);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks List all reconciliation breaks associated with a given run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfReconciliationRunBreak</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRunBreak> ListReconciliationBreaksWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->ListReconciliationBreaks");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->ListReconciliationBreaks");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliationBreaks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfReconciliationRunBreak>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}/breaks", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliationBreaks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks List all reconciliation breaks associated with a given run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfReconciliationRunBreak</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfReconciliationRunBreak> ListReconciliationBreaksAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRunBreak> localVarResponse = await ListReconciliationBreaksWithHttpInfoAsync(scope, code, runDate, version, effectiveAt, asAt, page, start, limit, filter, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationBreaks: List reconciliation breaks List all reconciliation breaks associated with a given run
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfReconciliationRunBreak)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRunBreak>> ListReconciliationBreaksWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->ListReconciliationBreaks");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->ListReconciliationBreaks");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliationBreaks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfReconciliationRunBreak>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}/breaks", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliationBreaks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings Lists all mappings this user is entitled to see
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ResourceListOfMapping</returns>
        public ResourceListOfMapping ListReconciliationMappings(string? reconciliationType = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfMapping> localVarResponse = ListReconciliationMappingsWithHttpInfo(reconciliationType);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings Lists all mappings this user is entitled to see
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ResourceListOfMapping</returns>
        public Lusid.Sdk.Client.ApiResponse<ResourceListOfMapping> ListReconciliationMappingsWithHttpInfo(string? reconciliationType = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (reconciliationType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "reconciliationType", reconciliationType));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliationMappings";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ResourceListOfMapping>("/api/portfolios/mapping", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliationMappings", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings Lists all mappings this user is entitled to see
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ResourceListOfMapping</returns>
        public async System.Threading.Tasks.Task<ResourceListOfMapping> ListReconciliationMappingsAsync(string? reconciliationType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfMapping> localVarResponse = await ListReconciliationMappingsWithHttpInfoAsync(reconciliationType, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings Lists all mappings this user is entitled to see
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationType">Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfMapping)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfMapping>> ListReconciliationMappingsWithHttpInfoAsync(string? reconciliationType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (reconciliationType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "reconciliationType", reconciliationType));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliationMappings";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ResourceListOfMapping>("/api/portfolios/mapping", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliationMappings", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs List all runs for a given reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfReconciliationRun</returns>
        public PagedResourceListOfReconciliationRun ListReconciliationRuns(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRun> localVarResponse = ListReconciliationRunsWithHttpInfo(scope, code, effectiveAt, asAt, page, start, limit, filter);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs List all runs for a given reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfReconciliationRun</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRun> ListReconciliationRunsWithHttpInfo(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->ListReconciliationRuns");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->ListReconciliationRuns");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliationRuns";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfReconciliationRun>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliationRuns", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs List all runs for a given reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfReconciliationRun</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfReconciliationRun> ListReconciliationRunsAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRun> localVarResponse = await ListReconciliationRunsWithHttpInfoAsync(scope, code, effectiveAt, asAt, page, start, limit, filter, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliationRuns: List Reconciliation runs List all runs for a given reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation</param>
        /// <param name="code">The code of the reconciliation</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the reconciliation runs. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation runs. Defaults to returning the latest version              of each run if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliation runs; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the run date, specify \&quot;Date eq 10/03/2018\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfReconciliationRun)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliationRun>> ListReconciliationRunsWithHttpInfoAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->ListReconciliationRuns");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->ListReconciliationRuns");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliationRuns";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfReconciliationRun>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliationRuns", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations List all the scheduled reconciliations matching particular criteria
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfReconciliation</returns>
        public PagedResourceListOfReconciliation ListReconciliations(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliation> localVarResponse = ListReconciliationsWithHttpInfo(effectiveAt, asAt, page, start, limit, filter, propertyKeys);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations List all the scheduled reconciliations matching particular criteria
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfReconciliation</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliation> ListReconciliationsWithHttpInfo(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfReconciliation>("/api/portfolios/$scheduledReconciliations", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations List all the scheduled reconciliations matching particular criteria
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfReconciliation</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfReconciliation> ListReconciliationsAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliation> localVarResponse = await ListReconciliationsWithHttpInfoAsync(effectiveAt, asAt, page, start, limit, filter, propertyKeys, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListReconciliations: List scheduled reconciliations List all the scheduled reconciliations matching particular criteria
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the reconciliation type, specify \&quot;id.Code eq &#39;001&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;Reconciliation&#39; domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example &#39;Reconciliation/Broker/Id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfReconciliation)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfReconciliation>> ListReconciliationsWithHttpInfoAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "ReconciliationsApi.ListReconciliations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfReconciliation>("/api/portfolios/$scheduledReconciliations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListReconciliations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero. Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationResponse</returns>
        public ReconciliationResponse ReconcileGeneric(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationResponse> localVarResponse = ReconcileGenericWithHttpInfo(reconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero. Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<ReconciliationResponse> ReconcileGenericWithHttpInfo(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = reconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileGeneric";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ReconciliationResponse>("/api/portfolios/$reconcileGeneric", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileGeneric", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero. Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationResponse</returns>
        public async System.Threading.Tasks.Task<ReconciliationResponse> ReconcileGenericAsync(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationResponse> localVarResponse = await ReconcileGenericWithHttpInfoAsync(reconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are &#39;empty&#39; or null or zero. Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ReconciliationResponse>> ReconcileGenericWithHttpInfoAsync(ReconciliationRequest? reconciliationRequest = default(ReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = reconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileGeneric";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReconciliationResponse>("/api/portfolios/$reconcileGeneric", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileGeneric", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings Reconcile the holdings of two portfolios.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ResourceListOfReconciliationBreak</returns>
        public ResourceListOfReconciliationBreak ReconcileHoldings(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfReconciliationBreak> localVarResponse = ReconcileHoldingsWithHttpInfo(sortBy, start, limit, filter, portfoliosReconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings Reconcile the holdings of two portfolios.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ResourceListOfReconciliationBreak</returns>
        public Lusid.Sdk.Client.ApiResponse<ResourceListOfReconciliationBreak> ReconcileHoldingsWithHttpInfo(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            localVarRequestOptions.Data = portfoliosReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileHoldings";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ResourceListOfReconciliationBreak>("/api/portfolios/$reconcileholdings", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileHoldings", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings Reconcile the holdings of two portfolios.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ResourceListOfReconciliationBreak</returns>
        public async System.Threading.Tasks.Task<ResourceListOfReconciliationBreak> ReconcileHoldingsAsync(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfReconciliationBreak> localVarResponse = await ReconcileHoldingsWithHttpInfoAsync(sortBy, start, limit, filter, portfoliosReconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings Reconcile the holdings of two portfolios.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Order the results by these fields. Use use the &#39;-&#39; sign to denote descending order e.g. -MyFieldName (optional)</param>
        /// <param name="start">Optional. When paginating, skip this number of results (optional)</param>
        /// <param name="limit">Optional. When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use \&quot;left.portfolioId.code eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="portfoliosReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfReconciliationBreak)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfReconciliationBreak>> ReconcileHoldingsWithHttpInfoAsync(List<string>? sortBy = default(List<string>?), int? start = default(int?), int? limit = default(int?), string? filter = default(string?), PortfoliosReconciliationRequest? portfoliosReconciliationRequest = default(PortfoliosReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (start != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "start", start));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            localVarRequestOptions.Data = portfoliosReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileHoldings";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ResourceListOfReconciliationBreak>("/api/portfolios/$reconcileholdings", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileHoldings", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes. Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ListAggregationReconciliation</returns>
        public ListAggregationReconciliation ReconcileInline(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation> localVarResponse = ReconcileInlineWithHttpInfo(inlineValuationsReconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes. Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ListAggregationReconciliation</returns>
        public Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation> ReconcileInlineWithHttpInfo(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = inlineValuationsReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileInline";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ListAggregationReconciliation>("/api/portfolios/$reconcileInline", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileInline", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes. Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListAggregationReconciliation</returns>
        public async System.Threading.Tasks.Task<ListAggregationReconciliation> ReconcileInlineAsync(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation> localVarResponse = await ReconcileInlineWithHttpInfoAsync(inlineValuationsReconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes. Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inlineValuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListAggregationReconciliation)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation>> ReconcileInlineWithHttpInfoAsync(InlineValuationsReconciliationRequest? inlineValuationsReconciliationRequest = default(InlineValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = inlineValuationsReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileInline";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ListAggregationReconciliation>("/api/portfolios/$reconcileInline", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileInline", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation. Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TransactionsReconciliationsResponse</returns>
        public TransactionsReconciliationsResponse ReconcileTransactions(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<TransactionsReconciliationsResponse> localVarResponse = ReconcileTransactionsWithHttpInfo(transactionReconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation. Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TransactionsReconciliationsResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<TransactionsReconciliationsResponse> ReconcileTransactionsWithHttpInfo(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = transactionReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileTransactions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<TransactionsReconciliationsResponse>("/api/portfolios/$reconcileTransactions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileTransactions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation. Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionsReconciliationsResponse</returns>
        public async System.Threading.Tasks.Task<TransactionsReconciliationsResponse> ReconcileTransactionsAsync(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<TransactionsReconciliationsResponse> localVarResponse = await ReconcileTransactionsWithHttpInfoAsync(transactionReconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation. Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transactionReconciliationRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionsReconciliationsResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TransactionsReconciliationsResponse>> ReconcileTransactionsWithHttpInfoAsync(TransactionReconciliationRequest? transactionReconciliationRequest = default(TransactionReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = transactionReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileTransactions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<TransactionsReconciliationsResponse>("/api/portfolios/$reconcileTransactions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileTransactions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes. Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ListAggregationReconciliation</returns>
        public ListAggregationReconciliation ReconcileValuation(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation> localVarResponse = ReconcileValuationWithHttpInfo(valuationsReconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes. Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ListAggregationReconciliation</returns>
        public Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation> ReconcileValuationWithHttpInfo(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = valuationsReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileValuation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ListAggregationReconciliation>("/api/portfolios/$reconcileValuation", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileValuation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes. Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListAggregationReconciliation</returns>
        public async System.Threading.Tasks.Task<ListAggregationReconciliation> ReconcileValuationAsync(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation> localVarResponse = await ReconcileValuationWithHttpInfoAsync(valuationsReconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes. Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="valuationsReconciliationRequest">The specifications of the inputs to the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListAggregationReconciliation)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ListAggregationReconciliation>> ReconcileValuationWithHttpInfoAsync(ValuationsReconciliationRequest? valuationsReconciliationRequest = default(ValuationsReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = valuationsReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.ReconcileValuation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ListAggregationReconciliation>("/api/portfolios/$reconcileValuation", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReconcileValuation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation Update a given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Reconciliation</returns>
        public Reconciliation UpdateReconciliation(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Reconciliation> localVarResponse = UpdateReconciliationWithHttpInfo(scope, code, updateReconciliationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation Update a given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Reconciliation</returns>
        public Lusid.Sdk.Client.ApiResponse<Reconciliation> UpdateReconciliationWithHttpInfo(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->UpdateReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->UpdateReconciliation");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpdateReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Reconciliation>("/api/portfolios/$scheduledReconciliations/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation Update a given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Reconciliation</returns>
        public async System.Threading.Tasks.Task<Reconciliation> UpdateReconciliationAsync(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Reconciliation> localVarResponse = await UpdateReconciliationWithHttpInfoAsync(scope, code, updateReconciliationRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation Update a given scheduled reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation to be updated</param>
        /// <param name="code">The code of the reconciliation to be updated</param>
        /// <param name="updateReconciliationRequest">The updated definition of the reconciliation (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Reconciliation)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Reconciliation>> UpdateReconciliationWithHttpInfoAsync(string scope, string code, UpdateReconciliationRequest? updateReconciliationRequest = default(UpdateReconciliationRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->UpdateReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->UpdateReconciliation");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateReconciliationRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpdateReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Reconciliation>("/api/portfolios/$scheduledReconciliations/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break Update or create a given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRunBreak</returns>
        public ReconciliationRunBreak UpsertReconciliationBreak(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak> localVarResponse = UpsertReconciliationBreakWithHttpInfo(scope, code, runDate, version, upsertReconciliationBreakRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break Update or create a given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRunBreak</returns>
        public Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak> UpsertReconciliationBreakWithHttpInfo(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->UpsertReconciliationBreak");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->UpsertReconciliationBreak");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.Data = upsertReconciliationBreakRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpsertReconciliationBreak";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ReconciliationRunBreak>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertReconciliationBreak", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break Update or create a given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRunBreak</returns>
        public async System.Threading.Tasks.Task<ReconciliationRunBreak> UpsertReconciliationBreakAsync(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak> localVarResponse = await UpsertReconciliationBreakWithHttpInfoAsync(scope, code, runDate, version, upsertReconciliationBreakRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationBreak: Upsert a reconciliation break Update or create a given reconciliation break
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the break</param>
        /// <param name="code">The code of the reconciliation associated with the break</param>
        /// <param name="runDate">The date of the run associated with the break</param>
        /// <param name="version">The version number of the run associated with the break</param>
        /// <param name="upsertReconciliationBreakRequest">The definition of the reconciliation break request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRunBreak)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ReconciliationRunBreak>> UpsertReconciliationBreakWithHttpInfoAsync(string scope, string code, DateTimeOffset runDate, int version, UpsertReconciliationBreakRequest? upsertReconciliationBreakRequest = default(UpsertReconciliationBreakRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->UpsertReconciliationBreak");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->UpsertReconciliationBreak");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("runDate", Lusid.Sdk.Client.ClientUtils.ParameterToString(runDate)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.Data = upsertReconciliationBreakRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpsertReconciliationBreak";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReconciliationRunBreak>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs/{runDate}/{version}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertReconciliationBreak", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Mapping</returns>
        public Mapping UpsertReconciliationMapping(Mapping? mapping = default(Mapping?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Mapping> localVarResponse = UpsertReconciliationMappingWithHttpInfo(mapping);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Mapping</returns>
        public Lusid.Sdk.Client.ApiResponse<Mapping> UpsertReconciliationMappingWithHttpInfo(Mapping? mapping = default(Mapping?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = mapping;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpsertReconciliationMapping";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Mapping>("/api/portfolios/mapping", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertReconciliationMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mapping</returns>
        public async System.Threading.Tasks.Task<Mapping> UpsertReconciliationMappingAsync(Mapping? mapping = default(Mapping?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Mapping> localVarResponse = await UpsertReconciliationMappingWithHttpInfoAsync(mapping, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mapping">The mapping to be created / updated. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mapping)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Mapping>> UpsertReconciliationMappingWithHttpInfoAsync(Mapping? mapping = default(Mapping?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = mapping;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpsertReconciliationMapping";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Mapping>("/api/portfolios/mapping", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertReconciliationMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run Existing reconciliations will be updated, non-existing ones will be created
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReconciliationRun</returns>
        public ReconciliationRun UpsertReconciliationRun(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRun> localVarResponse = UpsertReconciliationRunWithHttpInfo(scope, code, upsertReconciliationRunRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run Existing reconciliations will be updated, non-existing ones will be created
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReconciliationRun</returns>
        public Lusid.Sdk.Client.ApiResponse<ReconciliationRun> UpsertReconciliationRunWithHttpInfo(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->UpsertReconciliationRun");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->UpsertReconciliationRun");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = upsertReconciliationRunRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpsertReconciliationRun";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ReconciliationRun>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertReconciliationRun", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run Existing reconciliations will be updated, non-existing ones will be created
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReconciliationRun</returns>
        public async System.Threading.Tasks.Task<ReconciliationRun> UpsertReconciliationRunAsync(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<ReconciliationRun> localVarResponse = await UpsertReconciliationRunWithHttpInfoAsync(scope, code, upsertReconciliationRunRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpsertReconciliationRun: Update or Create a reconciliation run Existing reconciliations will be updated, non-existing ones will be created
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the reconciliation associated with the run</param>
        /// <param name="code">The code of the reconciliation associated with the run</param>
        /// <param name="upsertReconciliationRunRequest">The definition of the reconciliation run (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReconciliationRun)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ReconciliationRun>> UpsertReconciliationRunWithHttpInfoAsync(string scope, string code, UpsertReconciliationRunRequest? upsertReconciliationRunRequest = default(UpsertReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ReconciliationsApi->UpsertReconciliationRun");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ReconciliationsApi->UpsertReconciliationRun");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = upsertReconciliationRunRequest;

            localVarRequestOptions.Operation = "ReconciliationsApi.UpsertReconciliationRun";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReconciliationRun>("/api/portfolios/$scheduledReconciliations/{scope}/{code}/runs", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertReconciliationRun", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}