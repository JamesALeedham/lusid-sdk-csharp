// <auto-generated>
// Copyright Â© 2018 FINBOURNE TECHNOLOGY LTD
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// </auto-generated>

namespace Finbourne
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// # Introduction
    ///
    /// This page documents the [LUSID
    /// APIs](https://api.finbourne.com/swagger), which allows authorised
    /// clients to query and update their data within the LUSID platform.
    ///
    /// SDKs to interact with the LUSID APIs are available in the following
    /// languages :
    ///
    /// * [C#](https://github.com/finbourne/lusid-sdk-csharp)
    /// * [Java](https://github.com/finbourne/lusid-sdk-java)
    /// * [JavaScript](https://github.com/finbourne/lusid-sdk-js)
    /// * [Python](https://github.com/finbourne/lusid-sdk-python)
    ///
    /// # Data Model
    ///
    /// The LUSID API has a relatively lightweight but extremely powerful data
    /// model.   One of the goals of LUSID was not to enforce on clients a
    /// single rigid data model but rather to provide a flexible foundation
    /// onto which clients can streamline their data.   One of the primary
    /// tools to extend the data model is through using properties.  Properties
    /// can be associated with amongst others: -
    /// * Transactions
    /// * Instruments
    /// * Portfolios
    ///
    /// The LUSID data model is exposed through the LUSID APIs.  The APIs
    /// provide access to both business objects and the meta data used to
    /// configure the systems behaviours.   The key business entities are: -
    /// * **Portfolios**
    /// A portfolio is the primary container for transactions and holdings.
    /// * **Derived Portfolios**
    /// Derived portfolios allow portfolios to be created based on other
    /// portfolios, by overriding or overlaying specific items
    /// * **Holdings**
    /// A holding is a position account for a instrument within a portfolio.
    /// Holdings can only be adjusted via transactions.
    /// * **Transactions**
    /// A Transaction is a source of transactions used to manipulate holdings.
    /// * **Corporate Actions**
    /// A corporate action is a market event which occurs to a instrument, for
    /// example a stock split
    /// * **Instruments**
    /// A instrument represents a currency, tradable instrument or OTC contract
    /// that is attached to a transaction and a holding.
    /// * **Properties**
    /// Several entities allow additional user defined properties to be
    /// associated with them.   For example, a Portfolio manager may be
    /// associated with a portfolio
    ///
    /// Meta data includes: -
    /// * **Transaction Types**
    /// Transactions are booked with a specific transaction type.  The types
    /// are client defined and are used to map the Transaction to a series of
    /// movements which update the portfolio holdings.
    /// * **Properties Types**
    /// Types of user defined properties used within the system.
    ///
    /// This section describes the data model that LUSID exposes via the APIs.
    ///
    /// ## Scope
    ///
    /// All data in LUSID is segregated at the client level.  Entities in LUSID
    /// are identifiable by a unique code.  Every entity lives within a logical
    /// data partition known as a Scope.  Scope is an identity namespace
    /// allowing two entities with the same unique code to co-exist within
    /// individual address spaces.
    ///
    /// For example, prices for equities from different vendors may be uploaded
    /// into different scopes such as `client/vendor1` and `client/vendor2`.  A
    /// portfolio may then be valued using either of the price sources by
    /// referencing the appropriate scope.
    ///
    /// LUSID Clients cannot access scopes of other clients.
    ///
    /// ## Schema
    ///
    /// A detailed description of the entities used by the API and parameters
    /// for endpoints which take a JSON document can be retrieved via the
    /// `schema` endpoint.
    ///
    /// ## Instruments
    ///
    /// LUSID has its own instrument master implementation (LUSID CORE) which
    /// sources reference data from multiple data vendors.
    /// [OpenFIGI](https://openfigi.com/) and [PermID](https://permid.org/) are
    /// used as the instrument identifier when uploading transactions,
    /// holdings, prices, etc.
    /// The API exposes a `instrument/lookup` endpoint which can be used to
    /// lookup these identifiers given other market identifiers.
    ///
    /// Cash can be referenced using the ISO currency code prefixed with
    /// "`CCY_`" e.g. `CCY_GBP`
    ///
    /// For any instrument that are not recognised by LUSID (eg OTCs) a client
    /// can upload a client defined instrument. Securitised portfolios and
    /// funds can be modelled as client defined instruments.
    ///
    /// ## Instrument Prices (Analytics)
    ///
    /// Instrument prices are stored in LUSID's Analytics Store
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | InstrumentUid|string|Unique instrument identifier |
    /// | Value|decimal|Value of the analytic, eg price |
    /// | Denomination|string|Underlying unit of the analytic, eg currency, EPS
    /// etc. |
    ///
    ///
    /// ## Instrument Data
    ///
    /// Instrument data can be uploaded to the system using the [Instrument
    /// Properties](#tag/InstrumentProperties) endpoint.
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | InstrumentUid|string|Unique instrument identifier |
    ///
    ///
    /// ## Portfolios
    ///
    /// Portfolios are the top-level entity containers within LUSID, containing
    /// transactions, corporate actions and holdings.    The transactions build
    /// up the portfolio holdings on which valuations, analytics profit &amp;
    /// loss and risk can be calculated.
    /// Properties can be associated with Portfolios to add in additional model
    /// data.  Portfolio properties can be changed over time as well.  For
    /// example, to allow a Portfolio Manager to be linked with a Portfolio.
    ///
    /// Additionally, portfolios can be securitised and held by other
    /// portfolios, allowing LUSID to perform "drill-through" into underlying
    /// fund holdings
    ///
    /// ### Reference Portfolios
    /// Reference portfolios are portfolios that contain only holdings or
    /// weights, as opposed to transactions, and are designed to represent
    /// entities such as indices.
    ///
    /// ### Derived Portfolios
    ///
    /// LUSID also allows for a portfolio to be composed of another portfolio
    /// via derived portfolios.  A derived portfolio can contain its own
    /// transactions and also inherits any transactions from its parent
    /// portfolio.  Any changes made to the parent portfolio are automatically
    /// reflected in derived portfolio.
    ///
    /// Derived portfolios in conjunction with scopes are a powerful construct.
    /// For example, to do pre-trade what-if analysis, a derived portfolio
    /// could be created a new namespace linked to the underlying live (parent)
    /// portfolio.  Analysis can then be undertaken on the derived portfolio
    /// without affecting the live portfolio.
    ///
    /// ### Portfolio Groups
    /// Portfolio groups allow the construction of a hierarchy from portfolios
    /// and groups.  Portfolio operations on the group are executed on an
    /// aggregated set of portfolios in the hierarchy.
    ///
    /// For example:
    ///
    /// * Global Portfolios _(group)_
    /// * APAC _(group)_
    /// * Hong Kong _(portfolio)_
    /// * Japan _(portfolio)_
    /// * Europe _(group)_
    /// * France _(portfolio)_
    /// * Germany _(portfolio)_
    /// * UK _(portfolio)_
    ///
    /// In this example **Global Portfolios** is a group that consists of an
    /// aggregate of **Hong Kong**, **Japan**, **France**, **Germany** and
    /// **UK** portfolios.
    ///
    /// ### Movements Engine
    /// The Movements engine sits on top of the immutable event store and is
    /// used to manage the relationship between input trading actions and their
    /// associated portfolio holdings.
    ///
    /// The movements engine reads in the following entity types:-
    /// * Posting Transactions
    /// * Applying Corporate Actions
    /// * Holding Adjustments
    ///
    /// These are converted to one or more movements and used by the movements
    /// engine to calculate holdings.  At the same time it also calculates
    /// running balances, and realised P&amp;L.  The outputs from the movements
    /// engine are holdings and transactions.
    ///
    /// ## Transactions
    ///
    /// A transaction represents an economic activity against a Portfolio.
    ///
    /// Transactions are processed according to a configuration. This will tell
    /// the LUSID engine how to interpret the transaction and correctly update
    /// the holdings. LUSID comes with a set of transaction types you can use
    /// out of the box, or you can configure your own set(s) of transactions.
    ///
    /// For more details see the [LUSID Getting Started Guide for transaction
    /// configuration.](https://support.finbourne.com/hc/en-us/articles/360016737511-Configuring-Transaction-Types)
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | TransactionId|string|Unique transaction identifier |
    /// | Type|string|LUSID transaction type code - Buy, Sell, StockIn,
    /// StockOut, etc |
    /// | InstrumentUid|string|Unique instrument identifier |
    /// | TransactionDate|datetime|Transaction date |
    /// | SettlementDate|datetime|Settlement date |
    /// | Units|decimal|Quantity of transaction in units of the instrument |
    /// | TransactionPrice|tradeprice|Execution price for the transaction |
    /// | TotalConsideration|currencyandamount|Total value of the transaction |
    /// | ExchangeRate|decimal|Rate between transaction and settle currency |
    /// | TransactionCurrency|currency|Transaction currency |
    /// | CounterpartyId|string|Counterparty identifier |
    /// | Source|string|Where this transaction came from |
    /// | NettingSet|string|  |
    ///
    ///
    /// ### Example Transactions
    ///
    /// #### A Common Purchase Example
    /// Three example transactions are shown in the table below.
    ///
    /// They represent a purchase of USD denominated IBM shares within a
    /// Sterling denominated portfolio.
    ///
    /// * The first two transactions are for separate buy and fx trades
    /// * Buying 500 IBM shares for $71,480.00
    /// * A foreign exchange conversion to fund the IBM purchase. (Buy
    /// $71,480.00 for &amp;#163;54,846.60)
    /// * The third transaction is an alternate version of the above trades.
    /// Buying 500 IBM shares and settling directly in Sterling.
    ///
    /// | Column |  Buy Trade | Fx Trade | Buy Trade with foreign Settlement |
    /// | ----- | ----- | ----- | ----- |
    /// | TransactionId | FBN00001 | FBN00002 | FBN00003 |
    /// | Type | Buy | FxBuy | Buy |
    /// | InstrumentUid | FIGI_BBG000BLNNH6 | CCY_USD | FIGI_BBG000BLNNH6 |
    /// | TransactionDate | 2018-08-02 | 2018-08-02 | 2018-08-02 |
    /// | SettlementDate | 2018-08-06 | 2018-08-06 | 2018-08-06 |
    /// | Units | 500 | 71480 | 500 |
    /// | TransactionPrice | 142.96 | 1 | 142.96 |
    /// | TradeCurrency | USD | USD | USD |
    /// | ExchangeRate | 1 | 0.7673 | 0.7673 |
    /// | TotalConsideration.Amount | 71480.00 | 54846.60 | 54846.60 |
    /// | TotalConsideration.Currency | USD | GBP | GBP |
    /// | Trade/default/TradeToPortfolioRate&amp;ast; | 0.7673 | 0.7673 |
    /// 0.7673 |
    ///
    /// [&amp;ast; This is a property field]
    ///
    /// #### A Forward FX Example
    ///
    /// LUSID has a flexible transaction modelling system, and there are a
    /// number of different ways of modelling forward fx trades.
    ///
    /// The default LUSID transaction types are FwdFxBuy and FwdFxSell. Other
    /// types and behaviours can be configured as required.
    ///
    /// Using these transaction types, the holdings query will report two
    /// forward positions. One in each currency.
    ///
    /// Since an FX trade is an exchange of one currency for another, the
    /// following two 6 month forward transactions are equivalent:
    ///
    /// | Column |  Forward 'Sell' Trade | Forward 'Buy' Trade |
    /// | ----- | ----- | ----- |
    /// | TransactionId | FBN00004 | FBN00005 |
    /// | Type | FwdFxSell | FwdFxBuy |
    /// | InstrumentUid | CCY_GBP | CCY_USD |
    /// | TransactionDate | 2018-08-02 | 2018-08-02 |
    /// | SettlementDate | 2019-02-06 | 2019-02-06 |
    /// | Units | 10000.00 | 13142.00 |
    /// | TransactionPrice |1 | 1 |
    /// | TradeCurrency | GBP | USD |
    /// | ExchangeRate | 1.3142 | 0.760919 |
    /// | TotalConsideration.Amount | 13142.00 | 10000.00 |
    /// | TotalConsideration.Currency | USD | GBP |
    /// | Trade/default/TradeToPortfolioRate | 1.0 | 0.760919 |
    ///
    /// ## Holdings
    ///
    /// A holding represents a position in a instrument or cash on a given
    /// date.
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | InstrumentUid|string|Unique instrument identifier |
    /// | HoldingType|string|Type of holding, eg Position, Balance,
    /// CashCommitment, Receivable, ForwardFX |
    /// | Units|decimal|Quantity of holding |
    /// | SettledUnits|decimal|Settled quantity of holding |
    /// | Cost|decimal|Book cost of holding in transaction currency |
    /// | CostPortfolioCcy|decimal|Book cost of holding in portfolio currency |
    /// | Transaction|TransactionDto|If this is commitment-type holding, the
    /// transaction behind it |
    ///
    ///
    /// ## Corporate Actions
    ///
    /// Corporate actions are represented within LUSID in terms of a set of
    /// instrument-specific 'transitions'.  These transitions are used to
    /// specify the participants of the corporate action, and the effect that
    /// the corporate action will have on holdings in those participants.
    ///
    /// *Corporate action*
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | SourceId|id|  |
    /// | CorporateActionCode|code|  |
    /// | AnnouncementDate|datetime|  |
    /// | ExDate|datetime|  |
    /// | RecordDate|datetime|  |
    /// | PaymentDate|datetime|  |
    ///
    ///
    ///
    /// *Transition*
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    ///
    ///
    /// ## Property
    ///
    /// Properties are key-value pairs that can be applied to any entity within
    /// a domain (where a domain is `trade`, `portfolio`, `security` etc).
    /// Properties must be defined before use with a `PropertyDefinition` and
    /// can then subsequently be added to entities.
    ///
    /// # Schemas
    ///
    /// The following headers are returned on all responses from LUSID
    ///
    /// | Name | Purpose |
    /// | --- | --- |
    /// | lusid-meta-duration | Duration of the request |
    /// | lusid-meta-success | Whether or not LUSID considered the request to
    /// be successful |
    /// | lusid-meta-requestId | The unique identifier for the request |
    /// | lusid-schema-url | Url of the schema for the data being returned |
    /// | lusid-property-schema-url | Url of the schema for any properties |
    ///
    /// # Error Codes
    ///
    /// | Code|Name|Description |
    /// | ---|---|--- |
    /// | &lt;a name="100"&gt;100&lt;/a&gt;|Personalisations not found|The
    /// personalisation(s) identified by the pattern provided could not be
    /// found, either because it does not exist or it has been deleted. Please
    /// check the pattern your provided. |
    /// | &lt;a name="101"&gt;101&lt;/a&gt;|NonRecursivePersonalisation|  |
    /// | &lt;a name="102"&gt;102&lt;/a&gt;|VersionNotFound|  |
    /// | &lt;a name="104"&gt;104&lt;/a&gt;|InstrumentNotFound|  |
    /// | &lt;a name="105"&gt;105&lt;/a&gt;|PropertyNotFound|  |
    /// | &lt;a name="106"&gt;106&lt;/a&gt;|PortfolioRecursionDepth|  |
    /// | &lt;a name="108"&gt;108&lt;/a&gt;|GroupNotFound|  |
    /// | &lt;a name="109"&gt;109&lt;/a&gt;|PortfolioNotFound|  |
    /// | &lt;a name="110"&gt;110&lt;/a&gt;|PropertySchemaNotFound|  |
    /// | &lt;a name="111"&gt;111&lt;/a&gt;|PortfolioAncestryNotFound|  |
    /// | &lt;a name="112"&gt;112&lt;/a&gt;|PortfolioWithIdAlreadyExists|  |
    /// | &lt;a name="113"&gt;113&lt;/a&gt;|OrphanedPortfolio|  |
    /// | &lt;a name="119"&gt;119&lt;/a&gt;|MissingBaseClaims|  |
    /// | &lt;a name="121"&gt;121&lt;/a&gt;|PropertyNotDefined|  |
    /// | &lt;a name="122"&gt;122&lt;/a&gt;|CannotDeleteSystemProperty|  |
    /// | &lt;a name="123"&gt;123&lt;/a&gt;|CannotModifyImmutablePropertyField|
    /// |
    /// | &lt;a name="124"&gt;124&lt;/a&gt;|PropertyAlreadyExists|  |
    /// | &lt;a name="125"&gt;125&lt;/a&gt;|InvalidPropertyLifeTime|  |
    /// | &lt;a name="127"&gt;127&lt;/a&gt;|CannotModifyDefaultDataType|  |
    /// | &lt;a name="128"&gt;128&lt;/a&gt;|GroupAlreadyExists|  |
    /// | &lt;a name="129"&gt;129&lt;/a&gt;|NoSuchDataType|  |
    /// | &lt;a name="132"&gt;132&lt;/a&gt;|ValidationError|  |
    /// | &lt;a name="133"&gt;133&lt;/a&gt;|LoopDetectedInGroupHierarchy|  |
    /// | &lt;a name="135"&gt;135&lt;/a&gt;|SubGroupAlreadyExists|  |
    /// | &lt;a name="138"&gt;138&lt;/a&gt;|PriceSourceNotFound|  |
    /// | &lt;a name="139"&gt;139&lt;/a&gt;|AnalyticStoreNotFound|  |
    /// | &lt;a name="141"&gt;141&lt;/a&gt;|AnalyticStoreAlreadyExists|  |
    /// | &lt;a name="143"&gt;143&lt;/a&gt;|ClientInstrumentAlreadyExists|  |
    /// | &lt;a name="144"&gt;144&lt;/a&gt;|DuplicateInParameterSet|  |
    /// | &lt;a name="147"&gt;147&lt;/a&gt;|ResultsNotFound|  |
    /// | &lt;a name="148"&gt;148&lt;/a&gt;|OrderFieldNotInResultSet|  |
    /// | &lt;a name="149"&gt;149&lt;/a&gt;|OperationFailed|  |
    /// | &lt;a name="150"&gt;150&lt;/a&gt;|ElasticSearchError|  |
    /// | &lt;a name="151"&gt;151&lt;/a&gt;|InvalidParameterValue|  |
    /// | &lt;a name="153"&gt;153&lt;/a&gt;|CommandProcessingFailure|  |
    /// | &lt;a name="154"&gt;154&lt;/a&gt;|EntityStateConstructionFailure|  |
    /// | &lt;a name="155"&gt;155&lt;/a&gt;|EntityTimelineDoesNotExist|  |
    /// | &lt;a name="156"&gt;156&lt;/a&gt;|EventPublishFailure|  |
    /// | &lt;a name="157"&gt;157&lt;/a&gt;|InvalidRequestFailure|  |
    /// | &lt;a name="158"&gt;158&lt;/a&gt;|EventPublishUnknown|  |
    /// | &lt;a name="159"&gt;159&lt;/a&gt;|EventQueryFailure|  |
    /// | &lt;a name="160"&gt;160&lt;/a&gt;|BlobDidNotExistFailure|  |
    /// | &lt;a name="162"&gt;162&lt;/a&gt;|SubSystemRequestFailure|  |
    /// | &lt;a name="163"&gt;163&lt;/a&gt;|SubSystemConfigurationFailure|  |
    /// | &lt;a name="165"&gt;165&lt;/a&gt;|FailedToDelete|  |
    /// | &lt;a name="166"&gt;166&lt;/a&gt;|UpsertClientInstrumentFailure|  |
    /// | &lt;a name="167"&gt;167&lt;/a&gt;|IllegalAsAtInterval|  |
    /// | &lt;a name="168"&gt;168&lt;/a&gt;|IllegalBitemporalQuery|  |
    /// | &lt;a name="169"&gt;169&lt;/a&gt;|InvalidAlternateId|  |
    /// | &lt;a
    /// name="170"&gt;170&lt;/a&gt;|CannotAddSourcePortfolioPropertyExplicitly|
    /// |
    /// | &lt;a name="171"&gt;171&lt;/a&gt;|EntityAlreadyExistsInGroup|  |
    /// | &lt;a name="173"&gt;173&lt;/a&gt;|EntityWithIdAlreadyExists|  |
    /// | &lt;a name="174"&gt;174&lt;/a&gt;|PortfolioDetailsDoNotExist|  |
    /// | &lt;a name="176"&gt;176&lt;/a&gt;|PortfolioWithNameAlreadyExists|  |
    /// | &lt;a name="177"&gt;177&lt;/a&gt;|InvalidTransactions|  |
    /// | &lt;a name="178"&gt;178&lt;/a&gt;|ReferencePortfolioNotFound|  |
    /// | &lt;a name="179"&gt;179&lt;/a&gt;|DuplicateIdFailure|  |
    /// | &lt;a name="180"&gt;180&lt;/a&gt;|CommandRetrievalFailure|  |
    /// | &lt;a name="181"&gt;181&lt;/a&gt;|DataFilterApplicationFailure|  |
    /// | &lt;a name="182"&gt;182&lt;/a&gt;|SearchFailed|  |
    /// | &lt;a
    /// name="183"&gt;183&lt;/a&gt;|MovementsEngineConfigurationKeyFailure|  |
    /// | &lt;a name="184"&gt;184&lt;/a&gt;|FxRateSourceNotFound|  |
    /// | &lt;a name="185"&gt;185&lt;/a&gt;|AccrualSourceNotFound|  |
    /// | &lt;a name="186"&gt;186&lt;/a&gt;|EntitlementsFailure|  |
    /// | &lt;a name="187"&gt;187&lt;/a&gt;|InvalidIdentityToken|  |
    /// | &lt;a name="188"&gt;188&lt;/a&gt;|InvalidRequestHeaders|  |
    /// | &lt;a name="189"&gt;189&lt;/a&gt;|PriceNotFound|  |
    /// | &lt;a name="190"&gt;190&lt;/a&gt;|InvalidSubHoldingKeysProvided|  |
    /// | &lt;a name="191"&gt;191&lt;/a&gt;|DuplicateSubHoldingKeysProvided|  |
    /// | &lt;a name="200"&gt;200&lt;/a&gt;|InvalidUnitForDataType|  |
    /// | &lt;a name="201"&gt;201&lt;/a&gt;|InvalidTypeForDataType|  |
    /// | &lt;a name="202"&gt;202&lt;/a&gt;|InvalidValueForDataType|  |
    /// | &lt;a name="203"&gt;203&lt;/a&gt;|UnitNotDefinedForDataType|  |
    /// | &lt;a name="204"&gt;204&lt;/a&gt;|UnitsNotSupportedOnDataType|  |
    /// | &lt;a name="205"&gt;205&lt;/a&gt;|CannotSpecifyUnitsOnDataType|  |
    /// | &lt;a name="206"&gt;206&lt;/a&gt;|UnitSchemaInconsistentWithDataType|
    /// |
    /// | &lt;a name="207"&gt;207&lt;/a&gt;|UnitDefinitionNotSpecified|  |
    /// | &lt;a name="208"&gt;208&lt;/a&gt;|DuplicateUnitDefinitionsSpecified|
    /// |
    /// | &lt;a name="209"&gt;209&lt;/a&gt;|InvalidUnitsDefinition|  |
    /// | &lt;a name="210"&gt;210&lt;/a&gt;|InvalidInstrumentIdentifierUnit|  |
    /// | &lt;a name="211"&gt;211&lt;/a&gt;|HoldingsAdjustmentDoesNotExist|  |
    /// | &lt;a name="212"&gt;212&lt;/a&gt;|CouldNotBuildExcelUrl|  |
    /// | &lt;a name="213"&gt;213&lt;/a&gt;|CouldNotGetExcelVersion|  |
    /// | &lt;a name="214"&gt;214&lt;/a&gt;|InstrumentByCodeNotFound|  |
    /// | &lt;a name="215"&gt;215&lt;/a&gt;|EntitySchemaDoesNotExist|  |
    /// | &lt;a name="216"&gt;216&lt;/a&gt;|FeatureNotSupportedOnPortfolioType|
    /// |
    /// | &lt;a name="-10"&gt;-10&lt;/a&gt;|ServerConfigurationError|  |
    /// | &lt;a name="-1"&gt;-1&lt;/a&gt;|Unknown error|  |
    ///
    /// </summary>
    public partial interface ILUSIDAPI : System.IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        JsonSerializerSettings SerializationSettings { get; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        JsonSerializerSettings DeserializationSettings { get; }

        /// <summary>
        /// Subscription credentials which uniquely identify client
        /// subscription.
        /// </summary>
        ServiceClientCredentials Credentials { get; }


        /// <summary>
        /// List all analytic stores in client
        /// </summary>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfAnalyticStoreKey>> ListAnalyticStoresWithHttpMessagesAsync(System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new analytic store for the given scope for the given date
        /// </summary>
        /// <param name='request'>
        /// A valid and fully populated analytic store creation request
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AnalyticStore>> CreateAnalyticStoreWithHttpMessagesAsync(CreateAnalyticStoreRequest request = default(CreateAnalyticStoreRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get an analytic store
        /// </summary>
        /// <param name='scope'>
        /// The analytics data scope
        /// </param>
        /// <param name='year'>
        /// The year component of the date for the data in the scope
        /// </param>
        /// <param name='month'>
        /// The month component of the date for the data in the scope
        /// </param>
        /// <param name='day'>
        /// The day component of the date for the data in the scope
        /// </param>
        /// <param name='asAt'>
        /// AsAt date
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AnalyticStore>> GetAnalyticStoreWithHttpMessagesAsync(string scope, int year, int month, int day, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new analytic store for the given scope for the given date
        /// </summary>
        /// <param name='scope'>
        /// The analytics data scope
        /// </param>
        /// <param name='year'>
        /// The year component of the date for the data in the scope
        /// </param>
        /// <param name='month'>
        /// The month component of the date for the data in the scope
        /// </param>
        /// <param name='day'>
        /// The day component of the date for the data in the scope
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteAnalyticStoreWithHttpMessagesAsync(string scope, int year, int month, int day, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Insert analytics into an existing analytic store for the given
        /// scope and date.
        /// </summary>
        /// <param name='scope'>
        /// The analytics data scope
        /// </param>
        /// <param name='year'>
        /// The year component of the date for the data in the scope
        /// </param>
        /// <param name='month'>
        /// The month component of the date for the data in the scope
        /// </param>
        /// <param name='day'>
        /// The day component of the date for the data in the scope
        /// </param>
        /// <param name='data'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AnalyticStore>> InsertAnalyticsWithHttpMessagesAsync(string scope, int year, int month, int day, IList<InstrumentAnalytic> data = default(IList<InstrumentAnalytic>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets a corporate action based on dates
        /// </summary>
        /// <param name='scope'>
        /// Scope
        /// </param>
        /// <param name='code'>
        /// Corporate action source id
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective Date
        /// </param>
        /// <param name='asAt'>
        /// AsAt Date filter
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfCorporateActionEvent>> GetCorporateActionsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Attempt to create/update one or more corporate action. Failed
        /// actions will be identified in the body of the response.
        /// </summary>
        /// <param name='scope'>
        /// The intended scope of the corporate action
        /// </param>
        /// <param name='code'>
        /// Source of the corporate action
        /// </param>
        /// <param name='actions'>
        /// The corporate actions to create
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertCorporateActionsResponse>> BatchUpsertCorporateActionsWithHttpMessagesAsync(string scope, string code, IList<CreateCorporateAction> actions = default(IList<CreateCorporateAction>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new PropertyDataFormat. Note: Only non-default formats can
        /// be created.
        /// </summary>
        /// <param name='request'>
        /// The definition of the new format
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataType>> CreateDataTypeWithHttpMessagesAsync(CreateDataTypeRequest request = default(CreateDataTypeRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lists all property data formats in the specified scope.
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='includeDefault'>
        /// </param>
        /// <param name='includeSystem'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfDataType>> ListDataTypesWithHttpMessagesAsync(string scope, bool? includeDefault = default(bool?), bool? includeSystem = default(bool?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets a property data format.
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='name'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataType>> GetDataTypeWithHttpMessagesAsync(string scope, string name, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update a PropertyDataFormat. Note: Only non-default formats can be
        /// updated.
        /// </summary>
        /// <param name='scope'>
        /// The scope of the format being updated
        /// </param>
        /// <param name='name'>
        /// The name of the format to update
        /// </param>
        /// <param name='request'>
        /// The new definition of the format
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataType>> UpdateDataTypeWithHttpMessagesAsync(string scope, string name, UpdateDataTypeRequest request = default(UpdateDataTypeRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Return the definitions for the specified list of units
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='name'>
        /// </param>
        /// <param name='units'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IUnitDefinition>> GetUnitsFromDataTypeWithHttpMessagesAsync(string scope, string name, IList<string> units = default(IList<string>), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create derived portfolio
        /// </summary>
        /// <remarks>
        /// Creates a portfolio that derives from an existing portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope into which to create the new derived portfolio
        /// </param>
        /// <param name='portfolio'>
        /// The root object of the new derived portfolio, containing a
        /// populated reference portfolio id and reference scope
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> CreateDerivedPortfolioWithHttpMessagesAsync(string scope, CreateDerivedTransactionPortfolioRequest portfolio = default(CreateDerivedTransactionPortfolioRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete portfolio details
        /// </summary>
        /// <remarks>
        /// Deletes the portfolio details for the given code
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteDerivedPortfolioDetailsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Attempt to create one or more client instruments. Failed
        /// instruments will be identified in the body of the response.
        /// </summary>
        /// <param name='definitions'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<TryAddClientInstruments>> BatchAddClientInstrumentsWithHttpMessagesAsync(IList<CreateClientInstrumentRequest> definitions = default(IList<CreateClientInstrumentRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Attempt to delete one or more client instruments. Failed
        /// instruments will be identified in the body of the response.
        /// </summary>
        /// <param name='uids'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeleteClientInstrumentsResponse>> BatchDeleteClientInstrumentsWithHttpMessagesAsync(IList<string> uids = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get an individual instrument by the unique instrument uid.
        /// Optionally, decorate each instrument with specific properties.
        /// </summary>
        /// <param name='uid'>
        /// The uid of the requested instrument
        /// </param>
        /// <param name='asAt'>
        /// As at date
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Keys of the properties to be retrieved
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Instrument>> GetInstrumentWithHttpMessagesAsync(string uid, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lookup a large number of instruments by supplying a collection of
        /// non-Finbourne codes.  Optionally, decorate each instrument with
        /// specific properties.
        /// </summary>
        /// <param name='codeType'>
        /// The type of identifier. Possible values include: 'Undefined',
        /// 'ReutersAssetId', 'CINS', 'Isin', 'Sedol', 'Cusip', 'Ticker',
        /// 'ClientInternal', 'Figi', 'CompositeFigi', 'ShareClassFigi',
        /// 'Wertpapier'
        /// </param>
        /// <param name='codes'>
        /// An array of codes
        /// </param>
        /// <param name='asAt'>
        /// As at date
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Keys of the properties to be retrieved
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<LookupInstrumentsFromCodesResponse>> LookupInstrumentsFromCodesWithHttpMessagesAsync(string codeType = default(string), IList<string> codes = default(IList<string>), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert instrument properties
        /// </summary>
        /// <param name='classifications'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertInstrumentPropertiesResponse>> BatchUpsertInstrumentPropertiesWithHttpMessagesAsync(IList<InstrumentProperty> classifications = default(IList<InstrumentProperty>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get the unique identifier for the SAML Identity Provider to be used
        /// by domain.
        /// </summary>
        /// <param name='domain'>
        /// The domain that the user will be logging in to.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> GetSamlIdentityProviderIdWithHttpMessagesAsync(string domain, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request an authorised url for an Excel client version
        /// </summary>
        /// <param name='version'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> GetExcelDownloadUrlWithHttpMessagesAsync(string version = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the current major application version
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionSummary>> GetLusidVersionsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a personalisation, recursing to get any referenced if required.
        /// </summary>
        /// <param name='pattern'>
        /// The search pattern or specific key
        /// </param>
        /// <param name='scope'>
        /// The scope level to request for. Possible values include: 'User',
        /// 'Group', 'Default', 'All'
        /// </param>
        /// <param name='recursive'>
        /// Whether to recurse into dereference recursive settings
        /// </param>
        /// <param name='wildcards'>
        /// Whether to apply wildcards to the provided pattern and pull back
        /// any matching
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPersonalisation>> GetPersonalisationsWithHttpMessagesAsync(string pattern = default(string), string scope = default(string), bool? recursive = false, bool? wildcards = false, IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert one or more personalisations
        /// </summary>
        /// <param name='personalisations'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertPersonalisationResponse>> UpsertPersonalisationsWithHttpMessagesAsync(IList<Personalisation> personalisations = default(IList<Personalisation>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete a personalisation at a specific scope (or use scope ALL to
        /// purge the setting entirely)
        /// </summary>
        /// <param name='key'>
        /// The key of the setting to be deleted
        /// </param>
        /// <param name='scope'>
        /// The scope to delete at (use ALL to purge the setting entirely).
        /// Possible values include: 'User', 'Group', 'Default', 'All'
        /// </param>
        /// <param name='group'>
        /// If deleting a setting at group level, specify the group here
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePersonalisationWithHttpMessagesAsync(string key = default(string), string scope = default(string), string group = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List all groups in a specified scope
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// A filter expression to apply to the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolioGroup>> ListPortfolioGroupsWithHttpMessagesAsync(string scope, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='request'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> CreatePortfolioGroupWithHttpMessagesAsync(string scope, CreatePortfolioGroupRequest request = default(CreatePortfolioGroupRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get an existing group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> GetPortfolioGroupWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update an existing group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='request'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> UpdatePortfolioGroupWithHttpMessagesAsync(string scope, string code, UpdatePortfolioGroupRequest request = default(UpdatePortfolioGroupRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete a group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePortfolioGroupWithHttpMessagesAsync(string scope, string code, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate data in a group hierarchy
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='request'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ListAggregationResponse>> GetAggregationByGroupWithHttpMessagesAsync(string scope, string code, AggregationRequest request = default(AggregationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Obsolete - Aggregation request data in a group hierarchy into a
        /// data tree
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='request'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<NestedAggregationResponse>> GetNestedAggregationByGroupWithHttpMessagesAsync(string scope, string code, AggregationRequest request = default(AggregationRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets all commands that modified the portfolio groups(s) with the
        /// specified id.
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The portfolio group id
        /// </param>
        /// <param name='fromAsAt'>
        /// Filters commands by those that were processed at or after this
        /// time. Null means there is no lower limit.
        /// </param>
        /// <param name='toAsAt'>
        /// Filters commands by those that were processed at or before this
        /// time. Null means there is no upper limit (latest).
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// A filter expression to apply to the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfProcessedCommand>> GetPortfolioGroupCommandsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromAsAt = default(System.DateTimeOffset?), System.DateTimeOffset? toAsAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a full expansion of an existing group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='effectiveAt'>
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='propertyFilter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ExpandedGroup>> GetPortfolioGroupExpansionWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> propertyFilter = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add a portfolio to an existing group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='identifier'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> AddPortfolioToGroupWithHttpMessagesAsync(string scope, string code, ResourceId identifier = default(ResourceId), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Remove a portfolio that is currently present within an existing
        /// group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='portfolioScope'>
        /// </param>
        /// <param name='portfolioCode'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> DeletePortfolioFromGroupWithHttpMessagesAsync(string scope, string code, string portfolioScope, string portfolioCode, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add a sub group to an existing group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='identifier'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> AddSubGroupToGroupWithHttpMessagesAsync(string scope, string code, ResourceId identifier = default(ResourceId), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Remove a subgroup that is currently present within an existing
        /// group
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='subgroupScope'>
        /// </param>
        /// <param name='subgroupCode'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> DeleteSubGroupFromGroupWithHttpMessagesAsync(string scope, string code, string subgroupScope, string subgroupCode, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List scopes that contain portfolios
        /// </summary>
        /// <remarks>
        /// Lists all scopes that have previously been used
        /// </remarks>
        /// <param name='sortBy'>
        /// How to order the returned scopes
        /// </param>
        /// <param name='start'>
        /// The starting index for the returned scopes
        /// </param>
        /// <param name='limit'>
        /// The final index for the returned scopes
        /// </param>
        /// <param name='filter'>
        /// Filter to be applied to the list of scopes
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfScope>> ListPortfolioScopesWithHttpMessagesAsync(IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all portfolios
        /// </summary>
        /// <remarks>
        /// Get all portfolios in a scope
        /// </remarks>
        /// <param name='scope'>
        /// The scope to get portfolios from
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='asAt'>
        /// The asAt date to use
        /// </param>
        /// <param name='sortBy'>
        /// The columns to sort the returned data by
        /// </param>
        /// <param name='start'>
        /// How many items to skip from the returned set
        /// </param>
        /// <param name='limit'>
        /// How many items to return from the set
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolio>> ListPortfoliosWithHttpMessagesAsync(string scope, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get portfolio
        /// </summary>
        /// <remarks>
        /// Gets a single portfolio by code
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='asAt'>
        /// The asAt date to use
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> GetPortfolioWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update portfolio
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio to be updated
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='request'>
        /// The update request
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date for the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> UpdatePortfolioWithHttpMessagesAsync(string scope, string code, UpdatePortfolioRequest request = default(UpdatePortfolioRequest), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete portfolio
        /// </summary>
        /// <remarks>
        /// Deletes a portfolio from the given effectiveAt
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePortfolioWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate data in a portfolio
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='request'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ListAggregationResponse>> GetAggregationByPortfolioWithHttpMessagesAsync(string scope, string code, AggregationRequest request = default(AggregationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get modifications
        /// </summary>
        /// <remarks>
        /// Gets all commands that modified the portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The portfolio id
        /// </param>
        /// <param name='fromAsAt'>
        /// Filters commands by those that were processed at or after this
        /// time. Null means there is no lower limit.
        /// </param>
        /// <param name='toAsAt'>
        /// Filters commands by those that were processed at or before this
        /// time. Null means there is no upper limit (latest).
        /// </param>
        /// <param name='filter'>
        /// Command filter
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfProcessedCommand>> GetPortfolioCommandsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromAsAt = default(System.DateTimeOffset?), System.DateTimeOffset? toAsAt = default(System.DateTimeOffset?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get properties
        /// </summary>
        /// <remarks>
        /// Get properties attached to the portfolio.  If the asAt is not
        /// specified then
        /// the latest system time is used
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='asAt'>
        /// The asAt date to use
        /// </param>
        /// <param name='sortBy'>
        /// Property to sort the results by
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioProperties>> GetPortfolioPropertiesWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update properties
        /// </summary>
        /// <remarks>
        /// Create one or more properties on a portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='portfolioProperties'>
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date for the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioProperties>> UpsertPortfolioPropertiesWithHttpMessagesAsync(string scope, string code, IDictionary<string, PropertyValue> portfolioProperties = default(IDictionary<string, PropertyValue>), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete one, many or all properties from a portfolio for a specified
        /// effective date
        /// </summary>
        /// <remarks>
        /// Specifying no properties will delete all properties
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='portfolioPropertyKeys'>
        /// The keys of the property to be deleted. None specified indicates
        /// the intent to delete all properties
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePortfolioPropertiesWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), IList<string> portfolioPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets multiple property definitions.
        /// </summary>
        /// <param name='keys'>
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPropertyDefinition>> GetMultiplePropertyDefinitionsWithHttpMessagesAsync(IList<string> keys = default(IList<string>), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Creates a new property definition.
        /// </summary>
        /// <param name='definition'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertyDefinition>> CreatePropertyDefinitionWithHttpMessagesAsync(CreatePropertyDefinitionRequest definition = default(CreatePropertyDefinitionRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets a property definition.
        /// </summary>
        /// <param name='domain'>
        /// Possible values include: 'Trade', 'Portfolio', 'Security',
        /// 'Holding', 'ReferenceHolding', 'TxnType'
        /// </param>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertyDefinition>> GetPropertyDefinitionWithHttpMessagesAsync(string domain, string scope, string code, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Updates the specified property definition.
        /// </summary>
        /// <param name='domain'>
        /// Possible values include: 'Trade', 'Portfolio', 'Security',
        /// 'Holding', 'ReferenceHolding', 'TxnType'
        /// </param>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='definition'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertyDefinition>> UpdatePropertyDefinitionWithHttpMessagesAsync(string domain, string scope, string code, UpdatePropertyDefinitionRequest definition = default(UpdatePropertyDefinitionRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Deletes the property definition.
        /// </summary>
        /// <param name='domain'>
        /// Possible values include: 'Trade', 'Portfolio', 'Security',
        /// 'Holding', 'ReferenceHolding', 'TxnType'
        /// </param>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePropertyDefinitionWithHttpMessagesAsync(string domain, string scope, string code, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Perform a reconciliation between two portfolios
        /// </summary>
        /// <param name='request'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfReconciliationBreak>> PerformReconciliationWithHttpMessagesAsync(ReconciliationRequest request = default(ReconciliationRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a new reference portfolio
        /// </summary>
        /// <param name='scope'>
        /// The intended scope of the portfolio
        /// </param>
        /// <param name='referencePortfolio'>
        /// The portfolio creation request object
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> CreateReferencePortfolioWithHttpMessagesAsync(string scope, CreateReferencePortfolioRequest referencePortfolio = default(CreateReferencePortfolioRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all the constituents in a reference portfolio
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='effectiveAt'>
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfReferencePortfolioConstituent>> GetReferencePortfolioConstituentsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add constituents to a specific reference portfolio
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='code'>
        /// </param>
        /// <param name='effectiveAt'>
        /// </param>
        /// <param name='constituents'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertReferencePortfolioConstituentsResponse>> UpsertReferencePortfolioConstituentsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, IList<ReferencePortfolioConstituentRequest> constituents = default(IList<ReferencePortfolioConstituentRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Retrieve some previously stored results
        /// </summary>
        /// <param name='scope'>
        /// The scope of the data
        /// </param>
        /// <param name='key'>
        /// The key that identifies the data
        /// </param>
        /// <param name='date'>
        /// The date for which the data was loaded
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Results>> GetResultsWithHttpMessagesAsync(string scope, string key, System.DateTimeOffset date, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert precalculated results against a specified scope/key/date
        /// combination
        /// </summary>
        /// <param name='scope'>
        /// The scope of the data
        /// </param>
        /// <param name='key'>
        /// The key that identifies the data
        /// </param>
        /// <param name='date'>
        /// The date for which the data is relevant
        /// </param>
        /// <param name='request'>
        /// The results to upload
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Results>> UpsertResultsWithHttpMessagesAsync(string scope, string key, System.DateTimeOffset date, CreateResults request = default(CreateResults), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate data from a result set
        /// </summary>
        /// <param name='scope'>
        /// </param>
        /// <param name='resultsKey'>
        /// </param>
        /// <param name='request'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ListAggregationResponse>> GetAggregationByResultSetWithHttpMessagesAsync(string scope, string resultsKey, AggregationRequest request = default(AggregationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List all available entities
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfString>> ListEntitiesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets the schema for a given entity.
        /// </summary>
        /// <param name='entity'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Schema>> GetEntitySchemaWithHttpMessagesAsync(string entity, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get the schemas for the provided list of property keys
        /// </summary>
        /// <param name='propertyKeys'>
        /// A comma delimited list of property keys in string format. e.g.
        /// "Portfolio/default/PropertyName,Portfolio/differentScope/MyProperty"
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertySchema>> GetPropertySchemaWithHttpMessagesAsync(IList<string> propertyKeys = default(IList<string>), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets the available value types that could be returned in a schema
        /// </summary>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfValueType>> GetValueTypesWithHttpMessagesAsync(IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search portfolio groups
        /// </summary>
        /// <param name='request'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolioGroup>> PortfolioGroupsSearchWithHttpMessagesAsync(object request = default(object), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search portfolios
        /// </summary>
        /// <param name='request'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolioSearchResult>> PortfoliosSearchWithHttpMessagesAsync(object request = default(object), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search properties
        /// </summary>
        /// <param name='request'>
        /// </param>
        /// <param name='sortBy'>
        /// </param>
        /// <param name='start'>
        /// </param>
        /// <param name='limit'>
        /// </param>
        /// <param name='filter'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPropertyDefinition>> PropertiesSearchWithHttpMessagesAsync(object request = default(object), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets the list of persisted transaction types
        /// </summary>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfTransactionMetaData>> ListConfigurationTransactionTypesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Uploads a list of transaction types to be used by the movements
        /// engine
        /// </summary>
        /// <param name='types'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfTransactionMetaData>> SetConfigurationTransactionTypesWithHttpMessagesAsync(IList<TransactionConfigurationDataRequest> types = default(IList<TransactionConfigurationDataRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Adds a new transaction type movement to the list of existing types
        /// </summary>
        /// <param name='type'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<TransactionConfigurationData>> CreateConfigurationTransactionTypeWithHttpMessagesAsync(TransactionConfigurationDataRequest type = default(TransactionConfigurationDataRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create portfolio
        /// </summary>
        /// <remarks>
        /// Creates a new portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The intended scope of the portfolio
        /// </param>
        /// <param name='createRequest'>
        /// The portfolio creation request object
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> CreatePortfolioWithHttpMessagesAsync(string scope, CreateTransactionPortfolioRequest createRequest = default(CreateTransactionPortfolioRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get portfolio details
        /// </summary>
        /// <remarks>
        /// Gets the details for a portfolio.  For a derived portfolio this can
        /// be
        /// the details of another reference portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='asAt'>
        /// The asAt date to use
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioDetails>> GetDetailsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add/update portfolio details
        /// </summary>
        /// <remarks>
        /// Update the portfolio details for the given code or add if it
        /// doesn't already exist. Updates with
        /// null values will remove any existing values
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='details'>
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioDetails>> UpsertPortfolioDetailsWithHttpMessagesAsync(string scope, string code, CreatePortfolioDetails details = default(CreatePortfolioDetails), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get holdings
        /// </summary>
        /// <remarks>
        /// Get the aggregate holdings of a portfolio.  If no effectiveAt or
        /// asAt
        /// are supplied then values will be defaulted to the latest system
        /// time.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='asAt'>
        /// As at date
        /// </param>
        /// <param name='sortBy'>
        /// The columns to sort the returned data by
        /// </param>
        /// <param name='start'>
        /// How many items to skip from the returned set
        /// </param>
        /// <param name='limit'>
        /// How many items to return from the set
        /// </param>
        /// <param name='filter'>
        /// A filter on the results
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Keys for the instrument properties to be decorated onto the
        /// holdings
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionedResourceListOfHolding>> GetHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Set All Holdings
        /// </summary>
        /// <remarks>
        /// Create transactions in a specific portfolio to bring all holdings
        /// to the specified targets
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='holdingAdjustments'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AdjustHolding>> SetHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, IList<AdjustHoldingRequest> holdingAdjustments = default(IList<AdjustHoldingRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Adjust Selected Holdings
        /// </summary>
        /// <remarks>
        /// Create transactions in a specific portfolio to bring the selected
        /// holdings up to the specified targets
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='holdingAdjustments'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AdjustHolding>> AdjustHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, IList<AdjustHoldingRequest> holdingAdjustments = default(IList<AdjustHoldingRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Cancel adjust-holdings
        /// </summary>
        /// <remarks>
        /// Cancels a previous adjust holdings request
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Effective date
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> CancelAdjustHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets holdings adjustments in an interval of effective time.
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='fromEffectiveAt'>
        /// Events between this time (inclusive) and the toEffectiveAt are
        /// returned.
        /// </param>
        /// <param name='toEffectiveAt'>
        /// Events between this time (inclusive) and the fromEffectiveAt are
        /// returned.
        /// </param>
        /// <param name='asAtTime'>
        /// The as-at time for which the result is valid.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfHoldingsAdjustmentHeader>> ListHoldingsAdjustmentsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? toEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAtTime = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a holdings adjustment for a single portfolio at a specific
        /// effective time.
        /// If no adjustment exists at this effective time, not found is
        /// returned.
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective time of the holdings adjustment.
        /// </param>
        /// <param name='asAtTime'>
        /// The as-at time for which the result is valid.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<HoldingsAdjustment>> GetHoldingsAdjustmentWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, System.DateTimeOffset? asAtTime = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get transactions
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='fromTransactionDate'>
        /// Include transactions with a transaction date equal or later than
        /// this date. If not supplied, no lower filter is applied
        /// </param>
        /// <param name='toTransactionDate'>
        /// Include transactions with a transaction date equal or before this
        /// date. If not supplied, no upper filter is applied
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// The columns to sort the returned data by
        /// </param>
        /// <param name='start'>
        /// How many items to skip from the returned set
        /// </param>
        /// <param name='limit'>
        /// How many items to return from the set
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Keys for the instrument properties to be decorated onto the
        /// transactions
        /// </param>
        /// <param name='filter'>
        /// Transaction filter
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionedResourceListOfTransaction>> GetTransactionsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromTransactionDate = default(System.DateTimeOffset?), System.DateTimeOffset? toTransactionDate = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), IList<string> instrumentPropertyKeys = default(IList<string>), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert transactions
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='transactions'>
        /// The transactions to be updated
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertPortfolioTransactionsResponse>> UpsertTransactionsWithHttpMessagesAsync(string scope, string code, IList<TransactionRequest> transactions = default(IList<TransactionRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete transactions
        /// </summary>
        /// <remarks>
        /// Delete one or more transactions from a portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='id'>
        /// Ids of transactions to delete
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteTransactionsWithHttpMessagesAsync(string scope, string code, IList<string> id = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add/update transaction properties
        /// </summary>
        /// <remarks>
        /// Add one or more properties to a specific transaction in a portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='transactionId'>
        /// Id of transaction to add properties to
        /// </param>
        /// <param name='transactionProperties'>
        /// Transaction properties to add
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AddTransactionPropertyResponse>> AddTransactionPropertyWithHttpMessagesAsync(string scope, string code, string transactionId, IDictionary<string, PerpetualPropertyValue> transactionProperties = default(IDictionary<string, PerpetualPropertyValue>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete transaction property
        /// </summary>
        /// <remarks>
        /// Delete a property from a specific transaction
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='transactionId'>
        /// Id of the transaction to delete the property from
        /// </param>
        /// <param name='transactionPropertyKey'>
        /// The key of the property to be deleted
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePropertyFromTransactionWithHttpMessagesAsync(string scope, string code, string transactionId, string transactionPropertyKey = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get transactions
        /// </summary>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='asAt'>
        /// </param>
        /// <param name='sortBy'>
        /// The columns to sort the returned data by
        /// </param>
        /// <param name='start'>
        /// How many items to skip from the returned set
        /// </param>
        /// <param name='limit'>
        /// How many items to return from the set
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Keys for the instrument properties to be decorated onto the trades
        /// </param>
        /// <param name='filter'>
        /// Trade filter
        /// </param>
        /// <param name='parameters'>
        /// Core query parameters
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionedResourceListOfOutputTransaction>> BuildTransactionsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), IList<string> instrumentPropertyKeys = default(IList<string>), string filter = default(string), TransactionQueryParameters parameters = default(TransactionQueryParameters), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

    }
}
